\chapter{Revisão Bibliográfica}

Neste capítulo, são apresentados alguns fundamentos teóricos necessários para o
entendimento desta dissertação e alguns dos principais trabalhos e pesquisas
científicas relacionados ao controle de missão de robôs móveis. O objetivo deste
levantamento bibliográfico é apresentar técnicas viáveis e aplicações de
diversos sistemas de controle de missão, e direcionar o leitor para os
conhecimentos aplicados no controle de missão do robô DORIS, projeto que
envolve esta dissertação. Os estudos serão apresentados de forma cronológica.

Em 1986, um dos primeiros estudos em controle de missão foi desenvolvido por
Rodney Brooks, em BROOKS, R.A. [1] (Massachusetts Institute of Technology). Este
estudo é a base para diversos trabalhos atuais que envolvem controle de missão de robôs móveis. Os
desafios de robôs autônomos apontados por Brooks e que ainda ilustram os
problemas da atualidade são: \emph{múltiplos objetivos}, \emph{múltiplos
sensores}, \emph{robustez} e \emph{extensibilidade}. Esses desafios não são
suportados pela arquitetura tradicional de um sistema de controle, como será
visto adiante.

Os múltiplos objetivos de robôs móveis podem:
\begin{itemize}
  \item Ser conflitantes: por exemplo, um robô pode estar tentando alcançar um
  determinado ponto no espaço, porém evitando obstáculos locais.
  \item Ter relações de prioridade: por exemplo, um robô que inspeciona trilhos
  de trêm deve sair dos trilhos ao ouvir o sinal de um trêm chegando, mesmo se estiver
  finalizando a operação.
  \item Ser denpendentes: objetivos de \emph{alto nível} englobam diversos
  objetivos de \emph{baixo nível}. No caso do exemplo acima, o robô que sai do
  trilho para evitar o trêm deve se manter equilibrado para não cair. Outros
  artigos mais recentes, e que serão discutidos em outras subseções, separam
  esses objetivos em \emph{tarefas} (objetivos de \emph{alto nível}) e
  \emph{primitivas do veículo}.
\end{itemize}

Os múltiplos sensores de um robô móvel dependem de sua aplicação, porém
normalmente ele é provido de inúmeros sensores redundantes ou que são utilizados
para uma mesma tarefa. Por exemplo, a utilização de encoders para odometria e
localização, e câmeras que comparam quadros já coletados previamente também para
localização. Os sensores podem apresentar erros ou resultados conflitantes,
portanto a fusão da informação de múltiplos sensores, a determinação de seus
graus de confiabilidade e onde devem ser considerados são decisões que
o robô deve saber fazer.

Um robô deve ser robusto. Quando um sensor falha, o robô deve se
adaptar e utilizar os outros sensores que ainda funcionam para realizar as
tarefas. Quando o ambiente sofre alterações, o robô deve ser capaz de cumprir
determinadas funções essenciais.

A extensabilidade constitui em acrescentar mais sensores e,
portanto, aumentar a capacidade do robô, este pode executar novas tarefas.
Porém, isso vai esbarrar com a limitação de processamento do robô.

A modelagem de robôs de acordo com suas principais funcionalidades e o
desenvolvimento de novas arquiteturas para seus controles são o âmago no estudo
de controle de missão de robôs móveis. Brooks propõe uma
nova arquitetura, como pode ser visto na figura~\ref{BROOKS_1}. O autor
comenta que essa decomposição conduz a uma arquitetura radicalmente diferente para sistema de
controle de robôs móveis, com diferenças radicais em estratégias de
implementação a nível de hardware e com grandes vantagens em robustez,
construção e teste.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_1.pdf}
\caption{Arquitetura para sistema de controle de robôs móveis por Brooks}
\label{BROOKS_1}
\end{figure}

Na figura~\ref{BROOKS_1}, o autor define \emph{Níveis de competência}, que são
classes de comportamentos desejados para o robô sobre todos os ambientes que ele
pode encontrar. As classes são:
\begin{enumerate}
\setcounter{enumi}{-1}
  \item Evitar contato com objetos (estacionários ou móveis);
  \item Vaguear sem rumo sem bater em coisas;
  \item Explorar o ambiente vendo lugares a distância que são alcançáveis e
  seguir rumo em sua direção;
  \item Construir um mapa do ambiente e planejar trajetórias de um lugar para
  outro;
  \item Observar mudanças no ambiente;
  \item Raciocinar sobre o ambiente em termos de objetos identificáveis e
  realizar tarefas relacionadas a certos objetos;
  \item Formular e executar planos que envolvam mudar o estado do ambiente como
  desejado;
  \item Raciocinar sobre o comportamento de objetos no ambiente e modificar
  planos quando necessário;
\end{enumerate}
Vale observar que cada nível de competência inclui, como subconjunto, os
níveis de competência anteriores.

Após a decomposição na nova arquitetura, Brooks define as \emph{Camadas de
Controle}, correspondentes a cada nível de competência. A ideia dessa abordagem
é adicionar camadas de controle a níveis de competências superiores sem precisar
alterar a camada do nível anterior. Inicia-se, portanto, com a camada de
controle para o nível zero de competência, ela é testada e não será mais alterada. Depois é
criada a camanda de nível 1, capaz de examinar os dados da camada de nível 0 e
injetar dados nas interfaces internas do nível 0, suprimindo seu trânsito de
dados, figura~\ref{BROOKS_2}.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_2.pdf}
\caption{Camadas de controle de Brooks}
\label{BROOKS_2}
\end{figure}

Os problemas apresentados por Brooks são solucionados pela nova estrutura:
\begin{itemize}
  \item Múltiplos objetivos: camadas individuais podem trabalhar em objetivos
  individuais ao mesmo tempo. Os níveis das camadas de controle e o mecanismo de
  supressão do trânsito de dados resolvem os problemas de conflito, dependência
  e prioridade;
  \item Múltiplos sensores: as camadas utilizam os dados dos sensores
  independentemente, de forma que não há necessidade de se preocupar com a
  fusão;
  \item Robustez: além do uso inteligente de sensores, camadas de controle de
  baixo nível continuam a funcionar quando novas camadas de alto nível são
  adicionadas;
  \item Extensibilidade: cada camada de controle pode possuir o seu próprio
  processador; 
\end{itemize}

A estrutura das camadas de controle foram construídas por um conjunto de
pequenos processadores que enviam mensagens uns para os outros. Cada processador
é uma máquina de estado finito. A nova arquitetura e essa nova estrutura de
camadas com eventos discretos foram a base de diversos sistemas de controle de
missão da atualidade. A fim de melhor o entendimento desse sistema criado por
Brooks, serão apresentados dois níveis de seu controle em uma aplicação de robô
móvel.

A camada de controle nível zero deve garantir que o robô não entre em contato
com outros objetos, estacionários ou móveis. Portanto, o robô deve desviar se
algo se aproximar dele ou parar se algo estiver em sua trajetória. Na
figura~\ref{BROOKS_3}, podemos observar o nível 0 de controle do sistema.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_3.pdf}
\caption{Nível 0 de controle do sistema}
\label{BROOKS_3}
\end{figure}

Segue pequena descrição de cada módulo:
\begin{itemize}
  \item Módulo \emph{Curva}: comunica-se diretamente com o robô (atuadores).
  Recebe uma mensagem \emph{Dirigir} especificando um ângulo de giro seguido por
  uma mensagem do módulo \emph{Avanço} com uma determinada magnitude. Isso faz
  com que o robô realize uma curva e vá para o estado de \emph{Avanço}.
  \item Módulo \emph{Avanço}: comando o robô a se movimentar (atuadores), mas
  pára o robô se receber mensagem do módulo \emph{Colisão}. O robô fica inativo
  e mensagens do encoder é enviado ao módulo \emph{Curva}, funcionando como um
  \emph{reset}, e podendo receber novos comandos.
  \item Módulo \emph{Sonar}: recebe um vetor de informações de sensores do robô,
  filtra os dados e produz um mapeamento de obstáculos para o robô em
  coordenadas polares.
  \item Módulo \emph{Colisão}: monitora o mapa gerado pelo módulo \emph{Sonar}
  e, se detectar um obstáculo, envia um sinal de parada. Observe que este módulo
  funciona independentemente se o robô está em movimento ou parado.
  \item Módulo \emph{Sentir Força}: cada obstáculo detectado é somado
  como uma força repulsiva, gerando uma força resultante.
  \item Módulo \emph{Fugir}: monitora a força produzida pelos obstáculos e envia
  comandos para o módulo \emph{Curva} se a força for significante.
\end{itemize}
 
 A camada de controle nível 1, combinada a camada de controle nível 0, permite
 que o robô vagueie sem bater em obstáculos. A figura~\ref{BROOKS_3} mostra o
 sistema de controle aumentado pelo nível da camada 1.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_4.pdf}
\caption{Nível 0 e 1 de controle do sistema}
\label{BROOKS_4}
\end{figure}

Segue pequena descrição de cada módulo:
\begin{itemize}
  \item Módulo \emph{Vaguear}: gera nova direção para o robô a cada 20 segundos.
  \item Módulo \emph{Evitar}: recebe resultado da força computada pelo nível 0
  de controle e combina com a direção desejada pelo módulo \emph{Vaguear},
  produzindo uma nova direção desejada sem obstáculos. Esse resultado presume as
  computações do módulo \emph{Fugir}. Vale observar que o módulo \emph{Evitar}
  suprime a saída do módulo \emph{Fugir} (mecanismo de supressão). 
\end{itemize}

A nova arquitetura de Brooks é robusta, permite interações dinâmicas, flexível
para integrar novas funcionalidades, fácil para implementar e debugar, além de
associar sistemas de eventos discretos no controle de robôs autônomos,
utilizando como módulos básicos máquinas de estados finitos (FSM - \emph{Finite
State Machine}).
Vale ressaltar que a conexão de diversas FSM's não é uma FSM e, dessa forma,
Brooks acrescentou registradores e temporizadores em suas FSM.

Antes de Brooks, em 1983, Elfes, A. [7] (Carnegie-Mellon, Pensilvânia),já havia
idealizado uma arquitetura em módulos e controle distribuído a fim de atingir efetividade em processamento
paralelo, flexibilidade de interação com os diversos sensores, distribuir
capacidades de decisão e flexibilidade de expansão e modificação do sistema.
Porém o sistema de comunicação entre módulos era centralizado
(\emph{Blackboard}) e só realizavam uma determinada tarefa sob o comando de um
Plano de Controle (\emph{Control Plan}), que o usuário deve explicitamente
codificiar paralelismo, e os casos das exceções e condições inesperadas.

Em 1989, Chatila, R.G. [2] (Robotics And Artificial Intelligence Group,
Toulouse), descreve uma nova arquitetura e sistema de controle utilizando, assim como Brooks, módulos de forma hierárquica. A arquitetura do robô pode ser decomposta da seguinte forma:
\begin{itemize}
  \item Módulos de sensores: processam as saídas dos sensores. Os dados
  adquiridos por um sensor são processados pelo módulo de sensor e são tornados
  disponíveis para os módulos de nível mais alto para seus próprios
  processamentos e interpretaçõs.
  \item Unidades funcionais: realizam uma determinada função no robô. Por
  exemplo, localização do robô, combinando visão, odometria, laser e etc.
  \item Processos: realiza a dinâmica de malha fechada entre percpção e ação,
  usando unidades de função. O processo é representado por uma máquina de estado
  finito, onde suas entradas são os dados dos módulos dos sensores e suas saídas
  são comandos aos atuadores.
\end{itemize}
O sistema de controle de Chatila é composto por quatro componentes: Supervisor
(não implementado), Módulo Executivo, Gerente de Vigilância e Módulo de
Diagnóstico (não implementado). Os controles funcionam como um \emph{if - then},
com diversas condições e ações predeterminadas. O módulo de vigilância é
responsável por:
\begin{itemize}
  \item Indicar estados dos sensores e tomar ações de reflexo;
  \item Indica estado operacional do robô, como nível da bateria;
  \item Relatar plano e estado da missão que está sendo executada pelo robô;
\end{itemize}
O módulo executivo fucniona como um sistema operacional. Ele recebe comandos
(missões) predefinidas pela interface e se comunica com o módulo de vigilância.

Quando comparamos com Brooks, Chatila apresenta uma estrutura bem
rudimentar e lógica simples de arquitetura e controle. Apesar de utilizar a ideia de recursos
compartilhados nos módulos de sensores, os automatos dos módulos de processo
são bem simplificados e dependentes de um bloco central para resolver objetivos
conflitantes.

Em 1991, Saridis, F.Y. [3] (Center for Intelligent Robotic
Systems for Space Exploration, NASA), realizou
um dos primeiros trabalhos usando redes de Petri como módulos básicos para sistemas de
controle de missão, em vez de máquinas de estados finitos (Brooks).
Alguns PNT (\emph{Petri Net Transducers}) são usados para traduzir os comandos
gerados pelo nível de organização em algo compreensível para o nível de execução.

O sistema criado por Saridis, \emph{Intelligent Mobile Robot System}(IMRS), é
baseado na teoria de inteligência hierárquica de controle, Saridis [4].
Portanto, o IMRS possui a seguinte arquitetura, figura~\ref{Saridis_1}:
\begin{itemize}
  \item Nível organizacional (organizador de tarefas): gera tarefas de
  movimentação de alto nível.
  \item Nível de coordenação: funciona como uma interface entre o nível
  organizacional e o de execução. O nível é composto por um remetente e alguns
  coordenadores. O remetente recebe o plano da tarefa do organizador, decompõe a
  tarefa em ações de controlee remete aos coordenadores.Os coordenadores
  traduzem os comandos de controle em instruções de operação e as carrega ao
  dispositivo apropriado no nível de execução.
  \item Nível de execução: executa a instrução proveniente do nível de
  coordenação reporta seus resultados a ele.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/SARIDIS_1.pdf}
\caption{IMRS}
\label{Saridis_1} 
\end{figure}

A grande contribuição de Saridis foi a utilização de redes de Petri como módulo
básico de controle para seu sistema IMRS, já que as redes de Petri foram
originalmente introduzidas para descrever as comunicações de FSM's,
possibilitando flexibilidade e robustez. Além disso, é provado que redes de
Petri são excelente ferramenta para modelagem de sistemas, sobretudo quando
envolvem tarefas conflitantes ou simultâneas, Murata, T. [5]. Os fundamentos
teóricos sobre redes de Petri são abordados no capítulo 01 por serem essenciais para o
entendimento desta dissertação.

No trabalho de Saridis, o nível de coordenação do IMRS é composto por um remetente
(\emph{Dispatcher}) e três coordenadores: sistema de visão (VS), desvio de
obstáculo e controle de rastreamento (OATC), e planejamento de trajetórias (PP).
Com o modelo de redes de Petri não é possível implementar o esquema de linguagem de
decisão para descrever a tradução de tarefas entre remetente e coordenadores.
Portanto, os PNT (\emph{Petri Net transducer}) foram introduzidos como um
tradutor de linguagem: $PNT = (N,\Sigma,
\Delta, \sigma, \mu, F)$. Onde:
\begin{itemize}
	\item A rede de Petri $N=(P,T,I,O)$, $P$ lugares, $T$
transições, função de entrada $I$, função de saída $O$, é o controle da
tradução;
	\item $\mu$ é o estado inicial de $N$;
	\item $\Sigma$ é o alfabeto de entrada, representa tarefas de entradas;
	\item $\Delta$ é o alfabeto de saída, representa tarefas de saída; 
	\item $\sigma$ especifica, para uma dada tarefa de entrada, as transições em
$N$ e as subtarefas de saída que podem ser usadas na tarefa;
	\item $F$ é o estado final. Indica o fim da tradução da tarefa;
\end{itemize}    

Os quatro PNT's são combinados para realizarem a tradução de tarefas no Nível
de Coordenação: Remetente, sistema de visão, desvio de obstáculo
e controle de rastreamento, e planejamento de trajetórias.
Será brevemente descrito o componente Remetente (\emph{Dispatcher}) do modelo de
Nível de Coordenação para melhor entendimento do PNT.

Foram definidas quatro tarefas para o Nível de Coordenação: 1) \emph{wmu}:
atualização da memória 3-D do ambiente; 2) \emph{mod}: detecção de objetos em
movimento; 3) \emph{pp}: planejamento de trajetórias; 4) \emph{moac}: desvio de
obstáculos e controle de rastreamento; A figura~\ref{Saridis_2} mostra o modelo
de rede de Petri para o Remetente.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/SARIDIS_2.pdf}
\caption{Estrutura do nível de coordenação com foco na rede de Petri do
Remetente}
\label{Saridis_2}
\end{figure}

O estado inicial da rede de Petri é: $$M
=\{2,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$, cujos lugares são: $$M
=\{P_0,P_1,P_2,P_3,P_4,P_5,P_6,P_7,P_8,I_{PP},IS_{PP},\ldots$$
$$OS_{PP},O_{PP},I_{VS},IS_{VS},OS_{VS},
O_{VS},I_{OATC},IS_{OATC},OS_{OATC},O_{OATC}\}$$ .
As suas transições são:
\begin{enumerate}
  \item A transição $t_s$ inicializa o Remetente quando uma tarefa é recebida
  do Organizador. 
  $$M=\{1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$  
  O lugar $P_0$ permanece com um token, logo a transição $t_s$ ainda pode ser
  disparada. Isso faz com que o Remetente seja capaz de executar duas tarefas
  simultaneamente: a tarefa de movimentação (ver item 7) e o planejamento de
  trajetórias (ver item 3).
  \item A transição $t_{wmu}$ chama o processo de atualização do mapa 3-D. O
  sistema de visão poderá ser iniciado (token em $I_{VS}$) e a transição
  $t_{wmu}$ não pode ser disparada novamente até completar mais um ciclo de
  visão, graças ao \emph{Input Semaphore}, $IS_{VS}$.
  $$M=\{1,0,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,1,1,0\}$$
  Ao fim do ciclo do sistema de visão, o seu \emph{Output Point},$O_{VS}$,
  adquiri um token, habilitando a transição $t_{PP}$ do Remetente. 
  $$M=\{1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,1,1,0\}$$
  Vale observar as características que Brooks já utilizava em máquinas de estado
  como inibidores, supressores e níveis de competência.
  \item A transição $t_{pp}$ habilita o planejamento de trajetórias (token em
  $I_{PP}$), com restrições de espaço, cinemática, dinâmica e critério de
  otimização. $t_{pp}$ não pode ser disparada novamente até completar um
  ciclo de planejamento de trajetórias, graças ao \emph{Input Semaphore},
  $IS_{PP}$.
  $$M=\{1,0,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0\}$$
  Ao fim do ciclo do planejamento de trajetórias, o seu \emph{Output
  Point},$O_{PP}$, adquiri um token, habilitando a transição $t_{ssd}$ do
  Remetente.
  $$M=\{1,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,1,0\}$$
  \item A transição $t_{ssd}$ é disparada para colocar o estado do planejamento
  de trajetórias no valor inicial:
  $$M=\{1,0,0,0,1,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$
  \item A transição $t_{mod}$ é disparada para o desvio de obstáculo em um
  espaço especificado e provê acurácia e tempo requerido. O
  sistema de visão poderá ser iniciado novamente (token em $I_{VS}$) e a
  transição $t_{mod}$ não pode ser disparada novamente até completar mais um
  ciclo de visão, graças ao \emph{Input Semaphore}, $IS_{VS}$.
  $$M=\{1,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,1,0\}$$
  Ao fim do ciclo do sistema de visão, o seu \emph{Output Point},$O_{VS}$,
  adquiri um token, habilitando a transição $t_{moac}$ do Remetente. 
  $$M=\{1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,0,1,1,0\}$$
  \item A transição $t_{moac}$ é disparada e habilita o desvio de obstáculo
  e controle de rastreamento (token em $I_{OATC}$). O estado do sistema de visão volta para
  o valor inicial e $t_{moac}$ não pode ser disparada novamente até completar um
  ciclo de desvio de obstáculo, graças ao \emph{Input Semaphore}, $IS_{OATC}$.
  $$M=\{1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,1,0,1,0\}$$
  Ao fim do ciclo do desvio de obstáculo, o seu \emph{Output
  Point},$O_{OATC}$, adquiri um token, habilitando a transição $t_{ssd}$ do
  Remetente.
  $$M=\{1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1\}$$
  \item A transição $t_{mte}$ realiza a tarefa de movimentação do robô. O
  sistema de desvio de obstáculos e controle de rastreamento volta para o estado
  inicial.
  $$M=\{1,0,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$
  Caso haja falha, as transições $t_{cmo}$ ou $t_{cmn}$ podem ser disparadas.
  \item A transição $t_{fbo}$ dispara para o envio de \emph{feedbacks} ao
  Organizador.
  $$M=\{1,0,0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,1,0\}$$
  \item A transição $t_{cmn}$ é disparada em caso de falha na movimentação do
  robô. O robô continuará o seu movimento por um novo caminho. Volta ao item 2.
  $$M=\{1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$ 
  \item A transição $t_{cmo}$ é disparada em caso de falha na movimentação do
  robô. O robô continuará o seu movimento pelo mesmo caminho. Volta ao item 5.
  $$M=\{1,0,0,0,1,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$
  \item A transição $t_f$ dispara para reportar o resultado da movimentação do
  robô ao Organizador. Volta ao item 1.
  $$M=\{2,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$ 
\end{enumerate} 
A rede de Petri evidencia o motivo do uso dos PNT, com os parâmetros aumentados
$PNT = (N,\Sigma, \Delta, \sigma, \mu, F)$. Até agora, apenas as variáveis
diretamente ligadas à rede: $N$ e $\mu$ foram analisadas, mas quando se busca a
integração das redes dos coordenadores fica nítida a necessidade de parâmetros
para especificação das tarefas.

O alfabeto de entrada do Remetente é dado pelo Organizador, dado como
$\Sigma_0$. O alfabeto de saída ($\Delta_0$) são os alfabetos de entrada para
cada coordenador (PP, VS e OATC): $\Sigma_p = \{path\}$,
$\Sigma_m=\{\textrm{freemove}, \textrm{move}\}$ e
$\Sigma_v=\{\textrm{sendinfo.detection}, \textrm{terrain}\}$.

O parâmetro que especifica as transições para uma determinada tarefa e as
subtarefas é o $\sigma$. Para a transição $t_{mod}$, por exemplo,
$\sigma(t_{mod},mod)=\{\textrm{detection.sendinfo}(ard_i,ptc_i),
\textrm{sendinfo}(ard_i,ptc_i)\}$, onde $ard$ é a acurácia requerida sobre
objetos detectados em VS e $ptc$ é o tempo para a realização do processo. A rede
de Petri no coordenador VS pode, portanto, assumir transições paralelas (dois
caminhos) e o que define qual caminho deve ser seguido é o parêmetro do
Remetente (neste caso será a transição $t_{smd}$ de VS, [3]).

As contribuições de Saridis, em [3], foram, portanto:
\begin{itemize}
  \item Redes de Petri podem ser usadas como módulos básicos para sistemas de
  controle de missão de robôs móveis.
  \item A comunicação e conexão de módulos são eficientes entre redes de Petri.
  \item Controle e mecanismo de comunicação para coordenação de tarefas de um
  robô móvel podem ser realizados com redes de Petri.
\end{itemize} 

Em 1995, Espiau, B. [9] (INRIA, França), define sistemas híbridos como sistemas
que nem são puramente tempo contínuo, nem máquina de estado finito, mas que
combinam eventos discretos e componentes contínuos. Esses sistemas foram
estudados por duas comunidades distintas: ciência da computação e controle e
automação. Engenheiros de controle e automação estudam sistemas dinâmicos
(modelos) com ênfase nas teorias de estabilidade, convergência, robustez e
introduzem sistemas de eventos discretos para mudanças no controle ou no modelo.
A ciência da computação faz o caminho inverso: um estado em uma máquina de
estados representa um local de controle, onde variáveis mudam continuamente com
o tempo, de acordo com leis de evolução. A idéia controle híbrido são
desenvolvidas desde Brooks e aparece, mesmo que de forma rudimentar, nos
trabalhos apresentados anteriormente nesta dissertação.

Em 1996, Healey, A. J. [8] (Autonomous Underwater Vehicle Laboratory,
California), aplica técnicas de controle híbrido em seu trabalho de
desenvolvimento do AUV Phoenix.  É a partir de Healey
que são criados formalismo e terminologia apropriados nesse campo. O
controle híbrido será responsável tanto pela movimentação do veículo, contínuo
e síncrono, quanto pela sequência lógica das fases das missões, eventos
discreto com transições assíncronas.  



Haley propõe uma arquitetura de software híbrida com três níveis organizacionais
e hierárquicos, figura~\ref{HEALEY_1}: 
\begin{itemize}
  \item \textbf{Estratégico}: utiliza Prolog como linguagem de controle de
  missão. Desenvolve os comandos que levam o veículo a executar determinada
  missão.
  \item \textbf{Tático}: funções na linguagem C que faz interface com os
  predicados de Prolog e retorna \emph{TRUE / FALSE}. Este nível funciona de
  maneira assíncrona e retém os dados da missão, além de se comunicar com o
  nível de execução.
  \item \textbf{Operacional}: comanda os subsistemas do veículo a ativar funções
  de controle relacionadas ao nível tático.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/HEALEY_1.pdf}
\caption{Arquitetura do Robô Phoenix de Healey}
\label{HEALEY_1}
\end{figure}

A terminologia de Healey, essencial para os trabalhos futuros em controle de
missão, é apresentada a seguir. Assumindo o conjunto de todos os atuadores
disponíveis no veículo como $A$, o conjunto de sensores como $S$ e o conjunto de estados
contínuos como $X$:

\textbf{Definição}: Uma Função de Controle (CF) é o uso de um subconjunto
específico de atuadores $a_i \subset A$ com um subconjunto particular de
sensores $s_i \subset S$ para estimar um subconjunto de estados contínuos $x_i
\subset X$ e levar um certo subconjunto de erros $e_i$ para zero. Onde erro é
definido como a diferença entre um valor de comando (\emph{Set Point}) e um
estado atual estimado. A definição é análoga com a definição de Tarefa do Robô
(\emph{Robot Task}), em Espiau, B. [9] (INRIA, França).

\textbf{Definição}: Primitiva de Veículo é uma \emph{string} na linguagem de
programação, associada a uma Função de Controle. Por exemplo,
$Forward_Speed_Control$, controle de velocidade do veículo.

\textbf{Definição}: A Terminação de uma função de controle ocorre nas seguintes
condições:
\begin{itemize}
  \item Em um tempo especificado;
  \item Quando a função positiva definida do erro, $P(\cdot)$, assume valores
  limites especificados. Quando $b$ é um limite positivo e $F(\cdot)$ é um
  filtro passa-baixa, a Terminação ocorre se
  $$F(P(e)) < b$$
\end{itemize}  
\textbf{Definição}: Um Comportamento (B) é descrito como a execução de uma
sequência particular de CFs, cada uma com sua terminação. O estado de realizar
uma certa CF é um estado discreto do sistema. Um Comportamento pode ser
representado como uma rede de Petri, por exemplo.

\textbf{Definição}: Um Sistema de Controle Híbrido é um sistema de controle de
elementos de hardware e software capaz de conduzir o veículo por um conjunto de
Comportamentos.

\textbf{Definição}: Um Plano de Missão é a sequência de Comportamentos
conduzidos durante cada fase da missão, com tratamento de falhas.

Healey define diversas Primitivas de Veículo para AUVs, mas serão estudadas as
Primitivas do Robô MARIUS, de Silva, V., que é semelhante ao robô DORIS,
objeto de estudo desta dissertação.

Em 1996, Silva, V. et al [6] (Institute for Systems and Robotics, Lisboa),
projetaram, desenvolveram e testaram um sistema de controle de missão para o
MARIUS, robô autônomo submarino. \emph{A Mission Control System} (MCS), o
conceito, aparece pela primeira vez na nomenclatura como um sistema que:
\emph{i)} habilita o operador a definir uma missão ao veículo em uma linguagem
de alto nível, que será traduzida em um plano de missão; \emph{ii)} provê
ferramentas adequadas para converter um plano de missão em um programa de
missão que pode ser verificado e executado em tempo real; \emph{iii)} fornece
ao operador a capacidade de seguir o progresso do programa de missão enquanto
ele é executado, e modificá-lo se necessário;

O trabalho de Silva, V. [6], introduz novos e importantes conceitos chave para o
MCS: Tarefa do Sistema (\emph{System Task}), Primitiva do
Veículo (\emph{Vechicle Primitive}), Procedimento de Missão (\emph{Mission Procedure})
e Programa de Missão (\emph{Mission Program}). Além disso, a arquitetura do
veículo, por ser um AUV, possui sistemas e interconexões
semelhantes ao robô DORIS, estudo desta dissertação.

A arquitetura do veículo DORIS teve grande influência da organização do veículo
MARIUS descrita abaixo, figura~\ref{SILVA_1}:
\begin{itemize}
  \item \emph{Vehicle Support System} (VSS) - Controla a distribuição de energia
  aos hardwares instalados no veículo, monitora consumo de energia e detecta
  falhas de hardware, podendo enviar comandos de emergência.
  \item \emph{Actuator Control System} (ACS) - Controla a velocidade de rotação
  dos propulsores e posição dos ailerions e lemes. Os \emph{Set Points} dos
  atuadores são dados pelo \emph{Vehicle Guidance and Control System} (VGCS) e
  os dados dos atuadores são transmitidos para o \emph{Mission Control System}.
  \item \emph{Navigation System} (NS) - Estima posição linear e velocidade do
  veículo, orientação e velocidade angular. O sistema funde informações do
  \emph{Positioning System} (\emph{Long Baseline unit}) e \emph{Motion Sensor
  Integration System}, o qual inclui diversos sensores. As saídas do NS são
  entradas do VGCS, e enviadas ao MCS.
  \item \emph{Vehicle Guidance and Control System} (VGCS) - Recebe como entrada
  as trajetórias de referência pelo MCS, e os dados de navegação do NS. Suas
  saídas são \emph{Set Points} para velocidade de rotação e outros atuadores do
  ACS, tal que o veículo siga a trajetória desejada mesmo com incertezas e
  distúrbios.
  \item \emph{Communication System} (COMS) - Controla o link bidirecional usado
  pelo operador para passar missões ao MCS, e pelo veículo para passar status de
  missão ou estados do veículo.
  \item \emph{Environmental Inspection System} (EIS) - Coleta dados do ambiente
  com diversos sensores (inclusive câmeras), como temperatura, pressão, pH. É
  controlado pelo MCS.
  \item \emph{Data Logging System} (DLS) - Adquiri e armazena dados do veículo.
  \item \emph{Mission Control System} (MCS) - Sequencia e sincroniza a execução
  das tarefas básicas do veículo para uma determinada missão e provê a
  recuperação em caso de falhas.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/SILVA_1.pdf}
\caption{Arquitetura do Veículo MARIUS}
\label{SILVA_1}
\end{figure}


