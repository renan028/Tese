\chapter{Revisão Bibliográfica}

A modelagem de robôs de acordo com suas principais funcionalidades e o
desenvolvimento de novas arquiteturas são o âmago no estudo de
controle de missão de robôs móveis. Dessa forma, arquitetura robótica e controle
de missão são conceitos relacionados, e, portanto, o cerne desta pesquisa
bibliográfica.

Neste capítulo, são apresentados os fundamentos teóricos necessários para o
entendimento desta dissertação. O objetivo deste levantamento bibliográfico é
apresentar alguns dos principais trabalhos e pesquisas científicos sobre
arquiteturas e sistemas de controle de missão de robôs móveis. Por fim,
o leitor é direcionado para os conhecimentos aplicados no controle de missão do
robô DORIS, projeto que envolve esta dissertação.

O conceito de arquitetura %do grego arkhétékhton, do ingles architecture, do
% frances architecture
para robôs é definido de diferentes formas na
literatura. Em \cite{arkin1998behavior}, arquitetura de robô é
relacionada com arquitetura de software, em uma adaptação à
arquitetura de computadores de \cite{stone1980introduction}, e definida como:
arquitetura de robô é a disciplina dedicada ao projeto de robôs altamente específicos e individuais
a partir de uma coleção de blocos comuns de softwares.
Em \cite{mataric1992behavior}, a definição aborda sistemas de controle: uma
arquitetura fornece uma maneira principal de organizar um
sistema de controle, contudo, a arquitetura também impõe restrições sobre a
forma como o problema de controle pode ser resolvido. Já
em \cite{brooks1986robust}, o autor tenta associar a arquitetura de software
com os componentes de hardware (processadores) para compor a arquitetura
robótica.

O sistema robótico é composto por diversos elementos de hardware e
software que são interdependentes e necessários para o funcionamento do sistema.
Como o propósito deste trabalho é o desenvolvimento de uma arquitetura robótica
para o DORIS, sendo considerados os aspectos físicos, lógicos e a aplicabilidade do
robô, entende-se que uma arquitetura para robô móvel descreve uma maneira de se construir o
controle inteligente do robô, os módulos do sistema, como estes
módulos interagem entre si e seus elementos de hardware associados, visando sua
aplicação. A evolução das arquiteturas apresentadas nesta revisão
bibliográfica mostra que os elementos de hardware assumem um papel de grande
importância durante o desenvolvimento dessas arquiteturas, por exemplo como um
fator limitador, assim como a aplicação e o meio em que o robô está inserido.

De acordo com \cite{siegwart2004autonomous}, os componentes básicos de uma
arquitetura para robôs são classificados em três grupos: \textit{Percepção}, que
envolve as atividades de interpretação e integração dos sensores;
\textit{Planejamento} de tarefas, sincronização,
e o monitoramento da execução de todas as atividades do robô; \textit{Atuação},
que envolve as atividades de execução dos movimentos, ações do robô e controle
dos atuadores.

As três primeiras seções desta pesquisa bibliográfica abordam os paradigmas da
robótica, isto é, as três arquiteturas de operação de um sistema robótico:
paradigma hierárquico/deliberativo (SPA - \emph{Sense, Plan and Act}); paradigma
reativo; e paradigmo híbrido deliberativo/reativo. As seções apresentam e
exemplificam as arquiteturas pela ótica de diversos autores, e são
comparadas e analisadas.

%TODO: acrescentar mais uma referência (arkin?)
O controle de missão (\textit{Mission Control}) ou planejamento de missão
(\textit{Mission Planning}) ou planejamento de tarefas (\textit{Task Planning})
de robôs faz parte da arquitetura robótica, e pode ser desenvolvido para os
três tipos de arquiteturas. Em \cite{fryxell1996navigation}, o conceito é bem
introduzido como: controle de missão é um sistema que permite ao operador
definir as missões de um veículo em linguagem de alto nível; provê ferramentas adequadas para converter planos em
Progamas de Missões que podem ser verificados e executados em tempo real; e
permite ao operador saber o estado da missão enquanto esta é executada, e
modificá-la se for necessário. Em \cite{brumitt1996dynamic}, o conceito de
planejamento de missão é ampliado para múltiplos robôs: planejamento de missão
é o processo de determinar o que cada robô deve fazer para alcançar, de uma
maneira conjunta, os objetivos da missão, em um ambiente dinâmico.

Neste trabalho, o controle de missão de robôs é o componente da arquitetura
robótica que organiza e executa todas as tarefas do robô de maneira ótima,
exerce o papel de traduzir os comandos de missão do usuário ao robô, provê feedback ao
operador, e contém as diretivas do robô. Como faz parte da arquitetura, as
seções que seguem buscam, em cada arquitetura, destacar de forma exemplificada
alguns controles de missão.

\section{Paradigma hierárquico/deliberativo}
Em meados do século XX, são realizados os primeiros estudos de robôs autônomos,
juntamente com o aparecimento da Inteligência Artificial (IA). Em um sistema
robótico, a IA clássica consiste em um modelo centralizado que coleta
informações usando sensores, cria um modelo do ambiente, planeja o próximo
movimento e executa a ação. São sistemas do tipo \emph{Sense, Plan and
act} (SPA). Essa arquitetura de controle é clássica e tem abordagem
\emph{top-down} (hierárquica), como na decomposição tradicional,
figura~\ref{hierarquica}.

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/Hierarchical.png}
\caption{Arquitetura hierárquica tradicional.}
\label{hierarquica}
\end{figure}

De acordo com Marvin Minsky, uma máquina (robô) deveria tender a criar, por si
só, um modelo abstrato do ambiente em que está inserido (define-se
\emph{mundo}).
Caso fosse dado uma tarefa, ela primeiro poderia explorar soluções dentro de seu modelo abstrato e, então,
experimentá-las externamente. Seria como realizar uma simulação interna
e, caso funcionasse, realizá-la no mundo real.

\subsection{Robôs deliberativos}
Entre 1966 e 1972, Charles Rosen e Nils Nisson da Universidade de Stanford
criaram o Shakey, primeiro robô móvel autônomo (figura~\ref{SHAKEY_1}). Foi
desenvolvida uma inteligência artificial, \textit{problem solver}, chamada
STRIPS. Este sistema é um planejador de trajetórias que armazena as imformações
do ambiente (mapas e obstáculos) de maneira simbólica, e se dada uma tarefa de
deslocamento (\textit{goto}), é realizada uma busca lógica pelo sistema. 

Em 1977, começou a ser desenvolvido o projeto HILARE (figura~\ref{hilare}), no
Laboratoire d'Automatique et d'Analyse des Systèmes (LAAS), Toulouse, France.
O robô possuía sensores como câmera, ultrassons e laser para medir
distância, sendo possível atualizar o seu mundo com acurácia. Seu mundo era
representado por modelos geométricos e um modelo relacional que expressava a
conectividade dos quartos e corredores (simbólico) \cite{norelis1989control}.

Também em 1977, o Stanford Cart foi criado por Moravec para navegação e desvio
de obstáculos \cite{moravec1977towards}. Os obstáculos eram identificados pelo
robô durante a operação e representados em seu mundo interno como
esferas. O robô possuía uma segunda representação do mundo, simbólica por
grafos.

Em 1969, Victor Scheinman, Universidade de Stanford
\cite{scheinman1969design}, inventou o primeiro manipulador robótico
totalmente elétrico de seis elos e com solução completa e integrada de
cinemática inversa. Isto é, dado um ponto qualquer pertencente ao espaço de
trabalho do manipulador, este calcula o ângulo das juntas de forma que o
efetuador alcance o ponto especificado. Isso permitiu que o manipulador
percorresse trajetórias arbitrárias. Até os dias atuais, 2015, é ampla a
utilização de manipuladores industriais. A sofisticação destes sistemas já
possibilita que estes armazenem todo o conhecimento do mundo e executem tarefas
autônomas (figura~\ref{manipulador}).

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/SHAKEY_1.png}
\caption{Shakey robot}
\label{SHAKEY_1}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/HILARE.jpg}
\caption{HILARE}
\label{hilare}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/MANIPULADOR.jpg}
\caption{Manipulador robótico atual}
\label{manipulador}
\end{figure}

%TODO: Verificar controle de missão dos modelos
\subsection{Arquiteturas deliberativas}
As arquiteturas deliberativas são sistemas hierárquicos com a lógica
\textit{SPA}. São utilizados em sistemas robóticos até hoje, quando a aplicação
favorece seu uso e o poder computacional não é uma restrição.
Destacam-se os modelos de Albus, NASREM, \textit{Nested Hierarchical Controllers} e o \emph{Intelligent Mobile
Robot System}.

\subsubsection{Modelo de Albus}

Albus foi o pioneiro e mais influente autor de teorias em arquiteturas
deliberativas, \cite{albus1991outline}. Sua grande contribuição foi a
formalização e definição de diversos termos amplamente utilizados em automação e controle. Dentre outros, destaca-se o
teorema de que há quatro sistemas que compõem a inteligência: processamento de
sensores, modelo do mundo, geração de comportamentos e julgamento de valor. As
entradas desses elementos são os sensores e suas saídas são os atuadores:

\begin{itemize}
  \item Atuadores: as saídas de um sistema inteligente pe produzida por
  atuadores, como mover, posicionar braços, pernas, mãos, olhos e etc. Os
  atuadores naturais são os músculos e as glândulas, já os atuadores de máquinas
  são motores, pistões e válvulas.
  \item Sensores: são as entradas de um sistema inteligente, como sensores de
  força, torque, posição, velocidade, vibração, acústico, gases, temperatura e
  muitos outros. Monitoram o mundo e o estado interno do sistema, e provê dados
  ao sistema de processamento sensorial.
  \item Processamento sensorial: sistema que compara novas observações com a
  expectativa interna do modelo do mundo. Integra e armazena as diferenças e
  semelhanças encontradas, a fim de reconhecer padrões, objetos e relações no
  mundo.
  \item Modelo do mundo: é a melhor estimativa que o sistema inteligente possui
  do mundo, e atualizado pelo processamento sensorial. É um banco de dados com
  todo o conhecimento do mundo e contém uma capacidade de simulação que gera expectativas e predições. O modelo do mundo
  pode prover informações do passado, presente e prevê estados futuros.
  Os dados são importantes para: o gerador de comportamentos escolher o plano
  adequado para execução das ações; o processamento sensorial fazer correlações,
  comparação de modelos, e reconhecimento de objetos, estados e eventos; e o
  sistema de julgamento de valor computar valores de custo, benefício, risco,
  incerteza, importância e outros.
  \item Julgamento de valor: este é o sistema que determina o que é bom ou ruim,
  importante ou trivial, certo ou improvável. Computa custos, riscos e
  benefícios de situações observadas e atividades planejadas.
  \item Gerador de comportamentos: elemento que seleciona objetivos e planos,
  executa e monitora ações, e modifica planos existentes quando alguma situação
  do mundo exigir. Tarefas são decompostas em subtarefas, e subtarefas são
  sequências de objetivos. A ordem lógica de funcionamento é: o gerador de
  comportamentos cria planos, o modelo do mundo predita o resultado do plano, e
  o julgamento de valor avalia os resultados. O gerador de comportamento
  seleciona o plano com a avaliação mais alta.
\end{itemize}

As relações entre os elementos do sistema inteligente estão representados na
figura~\ref{albus}.  Esses elementos e suas relações possibilitaram a criação de
diversas arquiteturas.

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/albus.pdf}
\caption{Arquitetura de Albus para sistemas deliberativos.}
\label{albus}
\end{figure}

Vale ressaltar que, nesta arquitetura, o \textit{gerador de comportamentos} faz
o papel de controlador de missão.

\subsubsection{NASREM}
O NASREM \cite{albus1989nasa} foi uma arquitetura utilizada pela
NASA e possuía uma arquitetura com seis níveis de
funcionalidade (figura~\ref{nasrem}):

\begin{enumerate}
  \item Servo: provê o controle dos atuadores do robô (posição, velocidade e
  etc).
  \item Primitiva: determina as primitivas de movimento para gerar trajetórias
  suaves.
  \item Movimento elementar: define e planeja trajetórias livre de colisões.
  \item Tarefa: converte ações desejadas de um objeto em sequências de
  movimentos elementares.
  \item Compartimento de serviços: converte ações de grupos de objetos em
  tarefas de um objeto.
  \item Missão: decompõe o plano de missão em alto nível em compartimento de
  serviços.
\end{enumerate}

Vale ressaltar que, no modelo NASREM, o operador tem acesso a qualquer nível
hierárquico do robô e pode tomar o controle do robô para si, além de poder
substituir as entradas de sensores, modelo do mundo e outros. Dessa forma, o
nível de autonomia do robô pode ser desenvolvido de forma incremental.

A arquitetura hierárquica proposta em NASREM permite modularidade e propõe uma
metodologia de software.  
 
\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/NASREM.pdf}
\caption{Arquitetura NASREM.}
\label{nasrem}
\end{figure}

\subsubsection{\textit{Nested Hierarchical Controllers}}
O \textit{Nested Hierarchical Controllers} (NHC) consiste também em seis
níveis hierárquicos: planejador da missão, navegador, piloto, monitor de
trajetória, controlador, e sistema de controle de baixo nível. Há também
constante atualização do modelo do mundo por um sistema de sensoriamento.

O planejamento é decomposto em planejador da missão, navegador e piloto e seus
módulos são executados sequencialmente, tornando-se mais específico e detalhado.
A lógica é hierárquica: o planejador de missão envia trechos da missão para o
navegador, o qual envia trechos de trajetória para o piloto, que determina ações
ao controlador de baixo nível. A utilização do mapa interno do robô por cada
módulo é diferente, enquanto o planejador usa o mapa global, o piloto recebe
informações locais. Vale observar que, quando o modelo do mundo é atualizado,
muitas vezes não há necessidade de o planejador atualizar toda a missão e
recomeçar o ciclo de planejamento, apenas o piloto pode recalcular a trajetória
local. 
%TODO: FIGURA 

\subsubsection{\textit{Intelligent Mobile Robot System}}
Em 1991, Saridis \cite{wang1991petri} cria o \emph{Intelligent Mobile
Robot System} (IMRS) baseado na teoria de inteligência hierárquica de controle
\cite{saridis1988analytical}. Saridis utiliza redes de Petri como módulos
básicos da arquitetura para traduzir os comandos gerados pelo nível de
organização em algo compreensível para o nível de execução.

O IMRS possui a seguinte arquitetura (figura~\ref{Saridis_1}):
\begin{itemize}
  \item Nível organizacional (organizador de tarefas): gera tarefas de
  movimentação de alto nível.
  \item Nível de coordenação: funciona como uma interface entre o nível
  organizacional e o de execução. O nível é composto por um remetente e alguns
  coordenadores. O remetente recebe o plano da tarefa do organizador, decompõe a
  tarefa em ações de controle e remete aos coordenadores. Os coordenadores
  traduzem os comandos de controle em instruções de operação e transmite ao
  nível de execução.
  \item Nível de execução: executa a instrução proveniente do nível de
  coordenação e reporta seus resultados a ele.
\end{itemize}

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/SARIDIS_1.pdf}
\caption{IMRS}
\label{Saridis_1} 
\end{figure}

O nível de coordenação do IMRS é composto por um remetente
(\emph{Dispatcher}) e três coordenadores: sistema de visão (VS), desvio de
obstáculo e controle de rastreamento (OATC), e planejamento de trajetórias (PP).
Com o modelo de redes de Petri não é possível implementar o esquema de linguagem de
decisão para descrever a tradução de tarefas entre remetente e coordenadores.
Portanto, os \emph{Petri Net Transducers} (PNTs) foram introduzidos como
tradutores de linguagem (protocolo): $PNT = (N,\Sigma,
\Delta, \sigma, \mu, F)$. Onde:
\begin{itemize}
	\item A rede de Petri $N=(P,T,I,O)$, $P$ lugares, $T$
transições, função de entrada $I$, função de saída $O$, é o controle da
tradução;
	\item $\mu$ é o estado inicial de $N$;
	\item $\Sigma$ é o alfabeto de entrada, representa tarefas de entradas;
	\item $\Delta$ é o alfabeto de saída, representa tarefas de saída; 
	\item $\sigma$ especifica, para uma dada tarefa de entrada, as transições em
$N$ e as subtarefas de saída que podem ser usadas na tarefa;
	\item $F$ é o estado final. Indica o fim da tradução da tarefa;
\end{itemize}    

Os quatro PNT's são combinados para realizarem a tradução de tarefas no Nível
de Coordenação: remetente, sistema de visão, desvio de obstáculo
e controle de rastreamento, e planejamento de trajetórias. A
figura~\ref{Saridis_2} mostra o modelo de rede de Petri para o Remetente.
%Será brevemente descrito o componente Remetente (\emph{Dispatcher}) do modelo
% de Nível de Coordenação para melhor entendimento do PNT.

%Foram definidas quatro tarefas para o Nível de Coordenação: 1) \emph{wmu}:
%atualização da memória 3-D do ambiente; 2) \emph{mod}: detecção de objetos em
%movimento; 3) \emph{pp}: planejamento de trajetórias; 4) \emph{moac}: desvio de
%obstáculos e controle de rastreamento. A figura~\ref{Saridis_2} mostra o modelo
%de rede de Petri para o Remetente.

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth,angle=90]{figs/SARIDIS_2.pdf}
\caption{Estrutura do nível de coordenação com foco na rede de Petri do
Remetente}
\label{Saridis_2}
\end{figure}

A modelagem do sistema utilizando redes de Petri proporcionaram, como pode ser
visto na figura~\ref{Saridis_2}, algumas funcionalidades essenciais em uma
arquitetura robótica: a capacidade de executar duas tarefas simultaneamente, por
exemplo, movimentação e planejamento de trajetórias; e o \emph{Input Semaphore},
que impede um processo de ser executado até outro ser finalizado.
  
Saridis salienta os benefícios das PNT:
\begin{itemize}
  \item Redes de Petri podem ser usadas como módulos básicos para sistemas de
  controle de missão de robôs móveis.
  \item A comunicação e conexão de módulos são eficientes entre redes de Petri.
  \item Controle e mecanismo de comunicação para coordenação de tarefas de um
  robô móvel podem ser realizados com redes de Petri.
\end{itemize} 

A arquitetura de Saridis é uma contribuição importante por criar um nível
organizacional, separando o nível do desenvolvedor de baixo nível e um
nível de alto nível para um operador (usuário). Além disso, as redes de Petri
assumem um importante papel como módulo básico de controle para seu sistema
IMRS. As redes de Petri foram originalmente introduzidas para descrever as
comunicações de máquinas de estado finito (FSM), possibilitando flexibilidade
e robustez, e é provado que redes de Petri são uma excelente ferramenta para
modelagem de sistemas, sobretudo quando envolvem tarefas conflitantes ou
simultâneas \cite{murata1989petri}.


\subsection{Análise crítica}
A abordagem deliberativa simula, de certa forma, o processo de planejamento e
tomada de decisão do ser humano. Há um núcleo (cérebro) que
processa todos os dados sensorias e armazena o mundo, isto é, o ambiente em que
o robô está inserido, de maneira simbólica, geométrica ou outros tipos de
mapeamento. Além disso, o núcleo planeja todas as ações para uma determinada
tarefa, consultando sua ideia de mundo intensivamente. Há, também, sensores que
enviam suas novas informações periodicamente para o núcleo, (órgãos receptivos:
visão, olfato, e etc), atualizando o mundo. E há atuadores (músculos)
necessários para a realização das tarefas (figura~\ref{brain}).

É fácil observar que a arquitetura deliberativa é dependente do
modelo de mundo armazenado e suas atualizações periódicas. Portanto, a
utilização da abordagem deliberativa em ambientes extremamente dinâmicos pode ser muito
custosa devido às atualizações e ao replanejamento. Além disso, é fácil observar
que a arquitetura SPA dificulta a criação de sistemas em tempo real eficientes.
Dessa forma, robôs móveis em ambientes muito dinâmicos, como o carro autônomo da
google (figura~\ref{googlecar}), não são aplicações favoráveis para esta
arquitetura.

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/BRAIN.png}
\caption{Comparativo da arquitetura deliberativa com o ser humano.}
\label{brain}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/googlecar.jpg}
\caption{Projeto da google 2011- para o desenvolvimento de um carro autônomo.}
\label{googlecar}
\end{figure}

\section{Paradigma reativo}

Sistemas de arquitetura reativa também são chamados de sistemas baseados em
comportamentos. Os robôs são programados para agir através de ativação de uma
coleção de comportamentos primitivos de baixo nível. De acordo com
\cite{arkin1995reactive}, as principais características de sistemas puramente
reativos são:

\begin{itemize}
  \item Comportamentos são como elementos construtivos: são um par sensor-motor,
  onde o sensor provê informação necessária para o motor executar uma ação
  reativa, como desvio de obstáculo, atrair-se a objetivos, escapar de
  predadores e etc.
  \item Não há criação ou manutenção precisa do modelo do mundo. Os sistemas
  reagem ao estímulo do mundo, extremamente útil para mundos dinâmicos e
  hostis.
  \item Comportamentos de animais são normalmente utilizados para modelar esses
  sistemas.
\end{itemize}

Dessa forma, controle reativo é uma técnica que une percepção e ação,
tipicamente no contexto de comportamentos motores, para produzir respostas
robóticas em tempo real em mundos dinâmicos e não estruturados.

Em 1986, um dos primeiros estudos em sistemas reativos foi desenvolvido por
Rodney Brooks \cite{brooks1986robust}. Este estudo é a base para diversos
trabalhos atuais que envolvem robôs reativos móveis. Os desafios de
robôs autônomos apontados por Brooks e que ainda ilustram os problemas da
atualidade são: \emph{múltiplos objetivos}, \emph{múltiplos sensores},
\emph{robustez} e \emph{extensibilidade}. De acordo com Brooks, esses desafios
não são suportados pela arquitetura tradicional (paradigma hierárquico) de um
sistema de controle.

Os múltiplos objetivos de robôs móveis podem:
\begin{itemize}
  \item Ser conflitantes: por exemplo, um robô pode estar tentando alcançar um
  determinado ponto no espaço, porém evitando obstáculos locais.
  \item Ter relações de prioridade: por exemplo, um robô que inspeciona trilhos
  de trêm deve sair dos trilhos ao ouvir o sinal de um trêm chegando, mesmo se estiver
  finalizando a operação.
  \item Ser denpendentes: objetivos de \emph{alto nível} englobam diversos
  objetivos de \emph{baixo nível}. No caso do exemplo acima, o robô que sai do
  trilho para evitar o trêm deve se manter equilibrado para não cair. Artigos
  recentes, como em \cite{fryxell1996navigation} separam esses objetivos em
  \emph{tarefas} (objetivos de \emph{alto nível}) e \emph{primitivas do veículo}.
\end{itemize}

Robôs são normalmente providos de múltiplos sensores e suas diversas
informações podem ser redundantes, conflitantes ou complementares,
podendo ser utilizadas para uma mesma tarefa do robô.
Por exemplo, encoders para odometria e câmeras fixas ao robô
podem ser utilizados para localização, de forma que se complementem.
Os sensores podem apresentar erros ou resultados conflitantes, portanto a fusão
da informação de múltiplos sensores, a determinação de seus graus de
confiabilidade e em quais tarefas devem ser considerados são decisões que o
robô deve saber fazer.

Um robô deve ser robusto, isto é, em caso de falha de um sensor, o robô
deve se adaptar e utilizar os outros sensores que ainda funcionam para realizar as
tarefas. Ou em caso de alterações no ambiente, o robô deve ser
capaz de cumprir determinadas funções essenciais.

A extensibilidade constitui em acrescentar mais sensores e,
portanto, aumentar a capacidade do robô, sendo possível a execução de novas
tarefas. Porém, esta afirmação é normalmente criticada por alguns autores já que
existe um limite imposto pelo processamento do robô, já que um novo hardware
(sensor) é adicionado, mas o processamento (computador) não é substituído e sua
capacidade não é aumentada.

Brooks propõe um dos primeiros sistemas baseados em comportamentos, uma
arquitetura que tem como objetivo descentralizar a tomada de decisão de um
modelo central, como pode ser visto na figura~\ref{BROOKS_1}. O autor comenta
que essa decomposição conduz a uma arquitetura radicalmente diferente para
sistema de controle de robôs móveis em estratégias de implementação a nível de
hardware e com grandes vantagens em robustez, desenvolvimento e teste.

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_1.pdf}
\caption{Arquitetura para sistema de controle de robôs móveis por Brooks}
\label{BROOKS_1}
\end{figure}

\subsection{Robôs reativos}
Antes mesmo de Brooks, ou seja, antes da formalização de toda a teoria em
sistemas reativos, simples robôs eram criados na lógica de controle reativo e de
comportamentos. Em 1953, por exemplo, Grey Walter \cite{holland1997grey}
desenvolveu uma ``tartaruga'' elétrica capaz de se movimentar pelo ambiente,
evitando luz intensa (``ameaças'') e atraída por certos objetivos. Vale
observar a característica de perceber baixo nível de bateria e procurar
uma estação de recarga, comportamento que se sobrepõe aos outros. Os
comportamentos são simples e não há representação abstrata do mundo:
dirigir-se para luz fraca; fugir de luz forte; e evitar obstáculos.

Em 1984, veículos simples e puramente reativos com os pares clássicos
sensor-motor foram desenvolvidos pelo psicologista Braitenberg
\cite{braitenberg1986vehicles}, a fim de simular sentimentos, como covardia,
agressividade e outros. 

Em 2002 até os dias atuais, o robô iRobot Roomba ganha destaque comercial e
executa uma simples tarefa doméstica: limpar o chão. Em sua arquitetura, o robô
Roomba possui apenas algumas funções reativas, como esquivar-se e locomover-se,
e, em suas versões antigas, foi constatado que não possui o modelo do mundo,
mapa, dentro de si \cite{tribelhorn2007evaluating}.

%TODO: Verificar controle de missão dos modelos
\subsection{Arquiteturas reativas}
As arquiteturas reativas foram formalmente introduzidas em 1986 por
Roodney Brooks. O roboticista, futuro fundador da empresa iRobot, vivenciou uma
época de processadores lentos e de alto custo, dificultando o uso de diversos
sensores e a armazenagem do modelo do mundo no robô. Simulações de tarefas,
atualizações do mundo e análise de sensores como câmeras eram extremamente
complexas para robôs e impossíveis de serem executadas em tempo real. Brooks
vislumbrou como solução o processamento paralelo, evitar o uso de um modelo do
mundo e criar módulos puramente reativos, pares sensor-motor, que juntos compõem
o robô. 

O sistema de controle de arquiteturas reativas utilizam informações locais
do meio, obtidas pelos sensores do robô. Estas são simplificadamente tratadas,
de forma que a ação ao estímulo é tomada rapidamente e, assim, os robôs reativos
podem responder de forma mais rápida a variações do ambiente. A arquitetura
define como a informação é mapeada em uma ação e como é feita a coordenação dos
pares estímulo-ação (comportamentos reativos).

De acordo com Arkin \cite{arkin1998behavior}, há duas classes predominantes
para a função de coordenação: competitiva e cooperativa.

Um conflito ocorre quando dois ou mais comportamentos estão ativos ao mesmo
tempo e possuem respostas diferentes. Nesse caso, a coordenação de forma
competitiva entra em ação, escolhendo um dos comportamentos para a ação final do
robô. A prioridade de um comportamento sobre os demais pode ser definida
explicitamente em uma hierarquia entre os comportamentos, ou pode haver uma
votação por uma ação, ou outros métodos. O exemplo de sistema reativo com
coordenação do tipo competitiva é o desenvolvido por Brooks, arquitetura de
subsunção.

Na arquitetura cooperativa, a ação do robô é a fusão da resposta de todos os
comportamentos ativos. A arquitetura reativa esquema motor de Arkin é um exemplo
claro deste tipo de coordenação, onde cada comportamento influencia o movimento
do robô por meio de um vetor de força artificial e a ação resultante é
determinada pela soma vetoria de todos os vetores de força.


\subsubsection{Arquitetura de subsunção}
A arquitetura de subsunção é, neste trabalho, destacada, exemplificada e
minuciosamente comentada, já que sua lógica será o cerne da implementação da
camada reativa da DORIS.

Na figura~\ref{BROOKS_1}, Brooks define \emph{Níveis de competência}, que são
classes de comportamentos desejados para o robô sobre todos os ambientes que ele
pode encontrar. As classes definidas por Brooks são:
\begin{enumerate}
\setcounter{enumi}{-1}
  \item Evitar contato com objetos (estacionários ou móveis);
  \item Vaguear sem rumo e sem bater em objetos;
  \item Explorar o ambiente utilizando sensores, definir lugares alcançáveis, e
  seguir rumo em suas direções;
  \item Construir um mini-mapa do ambiente e planejar trajetórias de um lugar
  para outro;
  \item Observar mudanças no ambiente;
  \item Raciocinar sobre o ambiente em termos de objetos identificáveis e
  realizar tarefas relacionadas a certos objetos;
  \item Formular e executar planos que envolvam mudar o estado do ambiente como
  desejado;
  \item Raciocinar sobre o comportamento de objetos no ambiente e modificar
  planos quando necessário;
\end{enumerate}

Cada nível de competência inclui, como subconjunto, os
níveis de competência anteriores.

Após a decomposição na nova arquitetura, Brooks define as \emph{Camadas de
Controle}, correspondentes a cada nível de competência. A ideia dessa abordagem
é adicionar camadas de controle a níveis de competências superiores sem precisar
alterar a camada do nível inferior. Inicia-se, portanto, com a camada de
controle para o nível zero de competência, esta será testada e não mais
alterada. Após, é criada a camanda de nível 1, capaz de examinar os dados
da camada de nível 0 e injetar dados nas interfaces internas deste nível,
suprimindo seu trânsito de dados, figura~\ref{BROOKS_2}.

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_2.pdf}
\caption{Camadas de controle de Brooks}
\label{BROOKS_2}
\end{figure}

A camada de controle nível zero deve garantir que o robô não entre em contato
com outros objetos, estacionários ou móveis. Portanto, o robô deve desviar de
objetos que se aproximam ou parar se houver um objeto fixo em sua trajetória. A camada de controle nível 1, combinada a camada de controle nível 0, permite
 que o robô vagueie sem colisões. A figura~\ref{BROOKS_4} mostra o sistema de
 controle aumentado pelo nível da camada 1.


% \begin{figure}[h]
% \centering
% \includegraphics[width=1\columnwidth]{figs/BROOKS_3.pdf}
% \caption{Nível 0 de controle do sistema}
% \label{BROOKS_3}
% \end{figure}
% 
% Segue pequena descrição de cada módulo:
% \begin{itemize}
%   \item Módulo \emph{Curva}: comunica-se diretamente com o robô (atuadores).
%   Recebe uma mensagem \emph{Dirigir} especificando um ângulo de giro seguido por
%   uma mensagem do módulo \emph{Avanço} com uma determinada magnitude. Isso faz
%   com que o robô realize uma curva e vá para o estado de \emph{Avanço}.
%   \item Módulo \emph{Avanço}: comando faz robô se movimentar (atuadores), mas
%   pára o robô se receber mensagem do módulo \emph{Colisão}. O robô fica inativo
%   e mensagens do encoder é enviado ao módulo \emph{Curva}, funcionando como um
%   \emph{reset}, e podendo receber novos comandos.
%   \item Módulo \emph{Sonar}: recebe um vetor de informações de sensores do robô,
%   filtra os dados e produz um mapeamento de obstáculos para o robô em
%   coordenadas polares.
%   \item Módulo \emph{Colisão}: monitora o mapa gerado pelo módulo \emph{Sonar}
%   e, se detectar um obstáculo, envia um sinal de parada. Observe que este módulo
%   funciona independentemente se o robô está em movimento ou parado.
%   \item Módulo \emph{Sentir Força}: cada obstáculo detectado é somado
%   como uma força repulsiva, gerando uma força resultante.
%   \item Módulo \emph{Fugir}: monitora a força produzida pelos obstáculos e envia
%   comandos para o módulo \emph{Curva} se a força for significante.
% \end{itemize}
 
 

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_4.pdf}
\caption{Nível 0 e 1 de controle do sistema}
\label{BROOKS_4}
\end{figure}

% Segue pequena descrição de cada módulo do nível 1:
% \begin{itemize}
%   \item Módulo \emph{Vaguear}: gera nova direção para o robô a cada 20 segundos.
%   \item Módulo \emph{Evitar}: recebe resultado da força computada pelo nível 0
%   de controle e combina com a direção desejada pelo módulo \emph{Vaguear},
%   produzindo uma nova direção desejada sem obstáculos. Esse resultado presume as
%   computações do módulo \emph{Fugir}. Vale observar que o módulo \emph{Evitar}
%   suprime a saída do módulo \emph{Fugir} (mecanismo de supressão). 
% \end{itemize}
% 
% Os problemas anteriormente da arquitetura hierárquica apontados por Brooks
% são solucionados pela nova arquitetura:
% \begin{itemize}
%   \item Múltiplos objetivos: camadas individuais podem trabalhar em objetivos
%   individuais ao mesmo tempo. Os níveis das camadas de controle e o mecanismo de
%   supressão do trânsito de dados resolvem os problemas de conflito, dependência
%   e prioridade;
%   \item Múltiplos sensores: as camadas utilizam os dados dos sensores
%   independentemente, de forma que não há necessidade de se preocupar com a
%   fusão;
%   \item Robustez: além do uso inteligente de sensores, camadas de controle de
%   nível inferior continuam a funcionar quando novas camadas de nível superior
%   são adicionadas;
%   \item Extensibilidade: cada camada de controle pode possuir o seu próprio
%   processador, resolvendo o problema de adicionar sensores indefinidamente e
%   consumir o processamento;
% \end{itemize}

A estrutura das camadas de controle foram construídas por um conjunto de
pequenos processadores que enviam mensagens uns para os outros. Cada processador
é uma máquina de estado finito. A nova arquitetura e essa nova estrutura de
camadas com eventos discretos foram a base de diversos sistemas de controle de
missão da atualidade. A fim de melhorar o entendimento desse sistema criado
por Brooks, serão apresentados dois níveis de seu controle em uma aplicação de robô
móvel.

A nova arquitetura de Brooks é robusta, permite interações dinâmicas, é flexível
para integrar novas funcionalidades, em camadas superiores, e fácil para
implementar e debugar.
Brooks ainda associa sistemas de eventos discretos no controle de robôs autônomos,
utilizando como módulos básicos máquinas de estados finitos (FSM - \emph{Finite
State Machine}). Como a conexão de diversas FSM's não é uma FSM, a solução
encontrada por Brooks foi acrescentar inibidores e supressores em suas
FSM, chamando-as AFSM (\emph{Augmented Finite State Machine} ou máquina de
estado aumentada, FIGURA). Porém, o modelo hierárquico dos níveis cria uma certa
inflexibilidade nos níveis inferiores.
%TODO Colocar figura do modulo basico de brooks 

Apesar dos pontos positivos, a arquitetura de controle de um sistema
baseado em comportamento apresenta problemas com escala e contextualização
(\emph{situatedness}). 

O problema com escala é resultado das interconexões, que
podem crescer de maneira fatorial em relação ao número de comportamentos. 
A contextualização é um problema de sistemas de subsunção, onde subsistemas são
incluídos em um sistema mais amplo. Como cada comportamento é uma FSM, operando
concorrentemente com as outras, o comportamento corrente é o único estado no
qual o veículo como um todo funcionará, apesar de todos os estados estarem sendo
executados.

Apenas em 1996, Bellingham e Consi \cite{bellingham1994second}
propuseram um controle por camadas (\emph{Layered Control}) a fim de resolver o
problema de escala. Há um módulo de processamento de sensores que
disponibiliza os dados aos comportamentos, resolvendo o problema de
interconexões, já que antes as camadas superiores deveriam se conectar às
inferiores para obter os dados dos sensores. Porém, Bellingham não resolveu o
problema utilizando uma arquitetura do tipo subsunção: as camadas são associadas
com um número de prioridade, de forma que saídas conflitantes são resolvidas
com esse número. Esta solução pode gerar uma certa inflexibilidade, visto que
que uma nova ação pode alterar toda a estrutura de prioridades previamente
estabelecida.

A solução para o problema de contextualidade só foi resolvido em 2000 por Bennet
\cite{bennett2000behavior}. No \emph{State Configured Layered Control} (SCLC),
múltiplos conjuntos de comportamentos simples são escolhidos de uma biblioteca
de comportamentos e são executados em cada fase da missão. A vantagem é o
número reduzido de comportamentos executados ao mesmo tempo. Esta é
uma estratégia comum em arquiteturas de controle híbrido. 

\subsubsection{Arquitetura Esquema Motor}
Em 1987, Arkin \cite{arkin1987aura} utiliza a teoria de esquemas (psicologia)
proposta por \cite{arbib1992schema} para desenvolver sua função de coordenação
cooperativa para sistemas reativos, chamado de Esquema Motor. Neste sistema, as
respostas dos comportamentos aos estímulos são representadas por vetores
(magnitude e orientação) e a coordenação é alcançada pela adição dos vetores,
produzindo um vetor resultante. Não há hierarquia pré-definida entre
comportamentos, todos os comportamentos ativos contribuem
para a saída do sistema com sua resposta individual (vetor) e ganho
associado. O ganho do vetor (ou peso) é um parâmetro para dar flexibilidade,
possibilidade de aprendizado e adaptação do robô caso este não seja fixo.


Em uma tarefa de navegação, é fácil imaginar como funciona o método do Esquema
Motor. São definidos alguns esquemas motor (comportamentos), como mover-se em
direção ao objetivo, evitar obstáculos, desviar, escapar, e outros, e cada
comportamento responde com um vetor que representa velocidade (magnitude) e
direção (orientação) que o robô deve seguir. A soma dos vetores resulta
na direção e velocidade final do robô. Ao perceber um obstáculo, por
exemplo, os vetores do comportamento \textit{desvio de obstáculos} possuem
magnitude superior aos outros e orientação para fora do obstáculo (vetor de
repulsão), de forma que o robô executa o desvio, em vez de colidir.

Assim como a arquitetura de subsunção, no Esquema Motor, os esquemas agem de
maneira distribuída, paralela e são modulares. O sistema apresenta vantagem em
relação à arquitetura de camadas por sua dinâmica, já que os esquemas podem ser instanciados e desinstanciados a
qualquer momento, e fácil reconfiguração. Apesar do importante e atraente
resultado em tarefas de navegação, os esquemas motores dominaram apenas esse
nicho da robótica e, mesmo neste nicho, outras tarefas normalmente não são
executadas com esta arquitetura.

\subsection{Análise crítica}
Se a abordagem deliberativa simulava o processo de planejamento e tomada de
decisão do ser humano, os sistemas de arquitetura reativa simulam outra
importante função da medula espinhal, pertencente ao nosso sistema nervoso
central: o circuito reflexivo, ou arco reflexo. O reflexo é uma resposta
involuntária rápida, consciente ou não, originado de um estímulo externo e
realizada antes mesmo de o cérebro tomar conhecimento do estímulo periférico.

Dessa forma, não há planejamento, não há modelo de mundo, apenas uma reação ao
estímulo. Esse comportamento é extremamente importante e necessário para a
sobrevivência do ser humano. Por exemplo, quando encostamos a mão em
uma panela quente temos a reação imediata de retirar a mão sem intervenção do
cérebro, sem replanejamento, cujo processamento levaria tempo suficiente para
causar danos severos. É fácil, portanto, perceber que tais comportamentos devem
ser necessário também em robôs.

Robôs simples, como por exemplo um robô para limpar trilhos de trêm, ou robôs
para limpar o chão, podem ter o custo reduzido e executar extraordinariamente
bem suas tarefas sem a necessidade de planejamento e modelos complexos do mundo.
Durante a execução de sua tarefa, um robô limpador de trilhos só precisa saber
que é necessário sair do trilho ao avistar um trêm, e para isso basta um par
estímulo-motor e uma supressão de tarefa (no caso, a tarefa de continuar
limpando o trilho). 

A tabela\ref{comparativa} mostra a compração das arquiteturas analisadas até
agora.

\begin{table}[]
\centering
\caption{Tabela comparativa de arquitetura deliberativa e reativa}
\label{comparativa}
\begin{tabular}{ll}
\hline
\multicolumn{1}{|l|}{Arquiteturas deliberativas}                                                   & \multicolumn{1}{l|}{Arquiteturas reativas}                                                            \\ \hline
Modelo interno completo e preciso                                                                  & Informações sensoriais locais                                                                         \\
Planejamento                                                                                       & \begin{tabular}[c]{@{}l@{}}Ações pré-definidas às informações \\ sensoriais\end{tabular}              \\
\begin{tabular}[c]{@{}l@{}}Maior flexibilidade na definição de \\ tarefas e objetivos\end{tabular} & \begin{tabular}[c]{@{}l@{}}Sistemas mais dedicados às tarefas \\ e problemas específicos\end{tabular} \\
\begin{tabular}[c]{@{}l@{}}Resposta lenta às mudanças no \\ ambiente\end{tabular}                  & \begin{tabular}[c]{@{}l@{}}Resposta rápida às mudanças do \\ ambiente\end{tabular}                   
\end{tabular}
\end{table}

% Por outro lado, robôs de inspeção necessitam conhecer todo o ambiente, mundo,
% para identificar irregularidades e, por vezes, planejar sua locomoção em
% terrenos mais acidentados. A aplicação muitas vezes dita qual a arquitetura
% deverá ser usada
% non hard-wired
%TODO fechar análise

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/brain2.jpg}
\caption{Analogia de sistemas reativos com o ser humano.}
\label{brain2}
\end{figure}

\section{Paradigma híbrido ou deliberativo/reativo}

Arquiteturas deliberativas e reativas apresentam vantagens e
desvantagens e que muitas vezes se opõe. Por exemplo, é muito ineficiente
utilizar uma arquitetura deliberativa em um ambiente extremamente dinâmico,
assim como é ineficiente utilizar arquitetura reativa em uma linha de montagem
(manipuladores industriais). É natural pensar que integrando, de alguma forma,
as duas arquiteturas, formando uma arquitetura híbrida, será possível absorver
as vantagens de ambas.

Atualmente, os robôs com arquitetura híbrida predominam. Em muitas
aplicações de robôs móveis mais complexas, fica claro que formas de conhecimento
do mundo na arquitetura robótica permitem que a navegação dos robôs seja mais
flexível, eficiente e geral. A arquitetura híbrida tenta combinar os
métodos simbólicos da IA e seu uso de representação abstrata do modelo do mundo,
mas mantem o objetivo de prover robustez, resposta em tempo real e flexibilidade
dos sistemas puramente reativos. Arquiteturas híbridas podem permitir a
reconfiguração de controles reativos baseado no conhecimento do mundo através da
sua capacidade de raciocinar sobre os componentes comportamentais subjacentes.

O principal problema no paradigma híbrido é em como desenvolver uma
metodologia unificada de arquiteturas que garantem um sistema capaz de executar
planos de uma maneira robusta, como a arquitetura reativa, e, ao mesmo tempo,
ter um entendimento de alto nível da natureza do mundo e um modelo da intenção
do usuário.  

\subsection{Robôs híbridos}

\subsection{Aquitetura híbrida}
Em \cite{arkin1998behavior}, Arkin aponta quatro estratégias para o
projeto de arquiteturas híbridas:

\begin{itemize}
  \item Seleção: o planejador é visto como um configurador. O planejador
  determina a composição de comportamentos e parâmetros usados durante a
  execução. O planejador pode reconfigurá-los quando necessário devido a falhas
  no sistema.
  \item Conselho: o planejador é visto como um aconselhador. O planejador sugere
  mudanças que o controle reativo pode ou não usar.
  \item Adaptação: o planejador é visto como um adaptador. O planejador
  continuamente altera os componentes reativos ativos de acordo com as mudanças
  nas condições do mundo e requisitos de tarefas.
  \item Adiamento: o planejador é visto como um recurso para ser usado em último
  caso. Neste caso, os planos só são elaborados quando necessários.
\end{itemize}



\subsection{Análise crítica} 

Em 1996, Healey, A. J. [8] (Autonomous Underwater Vehicle Laboratory,
California), aplica técnicas de controle híbrido em seu trabalho de
desenvolvimento do AUV Phoenix.  O controle híbrido será responsável tanto pela
movimentação do veículo, contínuo e síncrono, quanto pela sequência lógica das
fases das missões, eventos discreto com transições assíncronas.  

Haley propõe uma arquitetura de software híbrida com três níveis organizacionais
e hierárquicos, figura~\ref{HEALEY_1}: 
\begin{itemize}
  \item \textbf{Estratégico}: utiliza Prolog como linguagem de controle de
  missão. Desenvolve os comandos que levam o veículo a executar determinada
  missão.
  \item \textbf{Tático}: funções na linguagem C que faz interface com os
  predicados de Prolog e retorna \emph{TRUE / FALSE}. Este nível funciona de
  maneira assíncrona e retém os dados da missão, além de se comunicar com o
  nível de execução.
  \item \textbf{Operacional}: comanda os subsistemas do veículo a ativar funções
  de controle relacionadas ao nível tático.
\end{itemize}

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/HEALEY_1.pdf}
\caption{Arquitetura do Robô Phoenix de Healey}
\label{HEALEY_1}
\end{figure}

Em 1996, Silva, V. et al [6] (Institute for Systems and Robotics, Lisboa),
projetaram, desenvolveram e testaram um sistema de controle de missão para o
MARIUS, robô autônomo submarino. O trabalho de Silva, V. [6], introduz novos e
importantes conceitos chave para o MCS: Tarefa do Sistema (\emph{System Task}), Primitiva do
Veículo (\emph{Vechicle Primitive}), Procedimento de Missão (\emph{Mission Procedure})
e Programa de Missão (\emph{Mission Program}). Além disso, a arquitetura do
veículo, por ser um AUV, possui sistemas e interconexões
semelhantes ao robô DORIS, estudo desta dissertação.

\textbf{Tarefa do Sistema} (ST): é a especificação paramétrica de uma classe
de algoritmos ou processos que implementam uma funcionalidade básica em um robô.
Reque a implementação de dois módulos: \textit{i}) um \emph{módulo Funcional}
que contém um determinado algoritmo e precesso, e transfere dados com outras
Tarefas do Sistema e dispositivos físicos; \textit{ii}) um \emph{módulo
Comando}, máquina de estado finito, que recebe comandos externos, produz
mensagens de saída, e controla a seleção de algoritmos, processos, e caminhos
dos dados para/de módulos Funcionais.

Na modelagem do sistema em redes de Petri, quando uma transição é
disparada, uma ST é executada, chamada através do seguinte cabeçalho:
$STname(D_{mode},Din_{st},P_m)$, onde $STname$ é o nome da ST, $D_{mode}$ é uma
string de dados de entrada que especifica um determinado algoritmo ou processo a
ser executado, e $Din_{st}$ é um conjunto de dados numéricos que são entrada
desses algoritmos ou processos. $P_m$ é um parâmetro para associar ST com
Primitivas do Veículo (descritos abaixo), indicando um número finito de lugares
na rede de Petri que devem ser marcados de acordo com o tipo da saída das
mensagens das STs.

As STs do MARIUS são semelhantes aos blocos da organização do veículo,
figura~\ref{SILVA_2}:
\emph{Vehicle Support Task} (VST), \emph{Actuator Control Task} (ACT),
\emph{Vehicle Navigation Task} (VNT), \emph{Motion Sensor Task} (MST),
\emph{Guidance and Control Task} (GCT), \emph{Vehicle Communications Task}
(VCT), \emph{Space and Time Task} (STT), \emph{Vehicle Log Taks} (VLT). 

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/SILVA_2.pdf}
\caption{Tarefas de Sistema do veículo MARIUS}
\label{SILVA_2}
\end{figure}

O exemplo de um cabeçalho que chama uma ST seria:
$GCT(YAW\_AUTO,\psi,p_{yaw\_auto})$, onde $GCT$ é o nome da ST, $YAW\_AUTO$
seleciona um modo de operação particular que implementa um controle automático
para guinada (\emph{yaw}), e $\psi$ é ângulo \emph{set-Point}.

\textbf{Primitiva do Veículo} (VP): é a especificação paramétrica de um modo
de operação elementar em um robô. Corresponde a ativação lógica e sincronizada
de um número de STs, as quais conduzem a um comportamento lógico e estrututrado
do veículo. Existe um conjunto de pré-condições, recursos alocados, exceções e
pós-condições associados às VPs, assim como as RT (Robot-Task) definidas em
Espiau.

A rede de Petri associada à VP é uma tupla de 5 parâmetros
$(P_{VP},T_{VP},A_{VP},\omega_{VP},X_{VP})$, onde $P_{VP},T_{VP}$ e $A_{VP}$ são
os conjuntos de lugares, transições e arcos, respectivamente, $\omega_{VP}$ é
uma função peso, e $X_{VP_{0}}$ é a condição inicial da rede de Petri. O
conjunto dos lugares pode ser decomposto em $P_{VP}=P_{pre}\cup P_{res}\cup
P_{err}\cup P_{loc}\cup P{pos}$, onde $P_{pre}$, $P_{res}$, $P_{err}$,
$P_{loc}$ e $P{pos}$ denotam os subconjuntos de lugares das pré-condições,
recursos alocados, erros, pós-condições, e os outros estados da rede de Petri,
respectivamente.

A transição em um Processo de Missão (descrito abaixo) inicializa a execução de
uma VP, chamada com o seguinte cabeçalho: $VPname(Din_{vp},P_m)$, onde
$Din_{vp}$ é o conjunto de dados numéricos que são entrada da VP e $P_m$ é o
parâmetro que associa a VP ao Processo de Missão.

\textbf{Processo de Missão} (MP): é a especificação paramétrica de uma Ação de
um sistema robótico. MP corresponde à cadeia lógica e temporal de VPs e,
possivelmente, outras MPs, as quais, em conjunto, executam uma determinada Ação.

A modelagem de MPs também pode ser em redes de Petri e é semelhante à VP, porém
em maior alto nível. O cabeçalho é: $MPname(Din_{mp},P_m)$, onde
$Din_{mp}$ é o conjunto de dados numéricos que são entrada do MP e $P_m$ é
similar à VP.

A arquitetura do veículo DORIS teve grande influência da organização do veículo
MARIUS descrita abaixo, figura~\ref{SILVA_1}:
\begin{itemize}
  \item \emph{Vehicle Support System} (VSS) - Controla a distribuição de energia
  aos hardwares instalados no veículo, monitora consumo de energia e detecta
  falhas de hardware, podendo enviar comandos de emergência.
  \item \emph{Actuator Control System} (ACS) - Controla a velocidade de rotação
  dos propulsores e posição dos ailerions e lemes. Os \emph{Set Points} dos
  atuadores são dados pelo \emph{Vehicle Guidance and Control System} (VGCS) e
  os dados dos atuadores são transmitidos para o \emph{Mission Control System}.
  \item \emph{Navigation System} (NS) - Estima posição linear e velocidade do
  veículo, orientação e velocidade angular. O sistema funde informações do
  \emph{Positioning System} (\emph{Long Baseline unit}) e \emph{Motion Sensor
  Integration System}, o qual inclui diversos sensores. As saídas do NS são
  entradas do VGCS, e enviadas ao MCS.
  \item \emph{Vehicle Guidance and Control System} (VGCS) - Recebe como entrada
  as trajetórias de referência pelo MCS, e os dados de navegação do NS. Suas
  saídas são \emph{Set Points} para velocidade de rotação e outros atuadores do
  ACS, tal que o veículo siga a trajetória desejada mesmo com incertezas e
  distúrbios.
  \item \emph{Communication System} (COMS) - Controla o link bidirecional usado
  pelo operador para passar missões ao MCS, e pelo veículo para passar status de
  missão ou estados do veículo.
  \item \emph{Environmental Inspection System} (EIS) - Coleta dados do ambiente
  com diversos sensores (inclusive câmeras), como temperatura, pressão, pH. É
  controlado pelo MCS.
  \item \emph{Data Logging System} (DLS) - Adquiri e armazena dados do veículo.
  \item \emph{Mission Control System} (MCS) - Sequencia e sincroniza a execução
  das tarefas básicas do veículo para uma determinada missão e provê a
  recuperação em caso de falhas.
\end{itemize}

\begin{figure}[h!]
\centering
\includegraphics[width=1\columnwidth]{figs/SILVA_1.pdf}
\caption{Arquitetura do Veículo MARIUS}
\label{SILVA_1}
\end{figure}

Silva desenvolveu os softwares CORAL e ATOL para implementação das VPs e STs em
redes de Petri de forma que um usuário final, como um operador, pudesse
facilmente criar seus MPs. A grande contribuição 

%TODO falar de blackboard quando for falar de ROS
Antes de Brooks, em 1983, Elfes, A. \cite{elfes1983distributed},já havia
idealizado uma arquitetura em módulos e controle distribuído a fim de atingir
efetividade em processamento paralelo, flexibilidade de interação com os
diversos sensores, distribuir capacidades de decisão e flexibilidade de
expansão e modificação do sistema.
Porém o sistema de comunicação entre módulos era centralizado
(\emph{Blackboard}) e só realizavam uma determinada tarefa sob o comando de um
Plano de Controle (\emph{Control Plan}). O usuário ainda deveria explicitamente
codificiar paralelismo, os casos das exceções e condições inesperadas.
