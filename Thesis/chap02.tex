\chapter{Revis�o Bibliogr�fica}

A modelagem de rob�s de acordo com suas principais funcionalidades e o
desenvolvimento de novas arquiteturas s�o o �mago no estudo de
controle de miss�o de rob�s m�veis. Dessa forma, arquitetura rob�tica e controle
de miss�o s�o conceitos relacionados, e, portanto, o cerne desta pesquisa
bibliogr�fica. 

Neste cap�tulo, s�o apresentados os fundamentos te�ricos necess�rios para o
entendimento desta disserta��o. O objetivo deste levantamento bibliogr�fico �
apresentar alguns dos principais trabalhos e pesquisas cient�ficos sobre
arquiteturas e sistemas de controle de miss�o de rob�s m�veis. Por fim,
o leitor � direcionado para os conhecimentos aplicados no controle de miss�o do
rob� DORIS, projeto que envolve esta disserta��o.

O conceito de arquitetura %do grego arkh�t�khton, do ingles architecture, do
% frances architecture
 para rob�s � definido de diferentes formas na
literatura. Em \cite{arkin1998behavior}, arquitetura de rob� �
relacionada com arquitetura de software, em uma adapta��o �
arquitetura de computadores de \cite{stone1980introduction}, e definida como:
arquitetura de rob� � a disciplina dedicada ao projeto de rob�s altamente espec�ficos e individuais
a partir de uma cole��o de blocos comuns de softwares.
Em \cite{mataric1992behavior}, a defini��o aborda sistemas de controle: uma
arquitetura fornece uma maneira principal de organizar um
sistema de controle, contudo, a arquitetura tamb�m imp�e restri��es sobre a
forma como o problema de controle pode ser resolvido. J�
em \cite{brooks1986robust}, o autor tenta associar a arquitetura de software
com os componentes de hardware (processadores) para compor a arquitetura
rob�tica.

O sistema rob�tico � composto por diversos elementos de hardware e
software que s�o interdependentes e necess�rios para o funcionamento do sistema.
Como o prop�sito deste trabalho � o desenvolvimento de uma arquitetura rob�tica
para o DORIS, sendo considerados os aspectos f�sicos, l�gicos e a aplicabilidade do
rob�, entende-se que uma arquitetura para rob� m�vel descreve uma maneira de se construir o
controle inteligente do rob�, os m�dulos do sistema, como estes
m�dulos interagem entre si e seus elementos de hardware associados, visando sua
aplica��o. A evolu��o das arquiteturas apresentadas nesta revis�o
bibliogr�fica mostra que os elementos de hardware assumem um papel de grande
import�ncia durante o desenvolvimento dessas arquiteturas, por exemplo como um
fator limitador, assim como a aplica��o e o meio em que o rob� est� inserido.

De acordo com \cite{siegwart2004autonomous}, os componentes b�sicos de uma
arquitetura para rob�s s�o classificados em tr�s grupos: \textit{Percep��o}, que
envolve as atividades de interpreta��o e integra��o dos sensores;
\textit{Planejamento} de tarefas, sincroniza��o,
e o monitoramento da execu��o de todas as atividades do rob�; \textit{Atua��o},
que envolve as atividades de execu��o dos movimentos, a��es do rob� e controle
dos atuadores.

As tr�s primeiras se��es desta pesquisa bibliogr�fica abordam os paradigmas da
rob�tica, isto �, as tr�s arquiteturas de opera��o de um sistema rob�tico:
paradigma hier�rquico/deliberativo (SPA - \emph{Sense, Plan and Act}); paradigma
reativo; e paradigmo h�brido deliberativo/reativo. As se��es apresentam e
exemplificam as arquiteturas pela �tica de diversos autores, e s�o
comparadas e analisadas.

%TODO: acrescentar mais uma refer�ncia (arkin?)
O controle de miss�o ou planejamento de miss�o de rob�s faz parte da arquitetura
rob�tica, e pode ser desenvolvido para os tr�s tipos de arquiteturas. Em
\cite{fryxell1996navigation}, � apresentada uma das primeiras defini��es de
controle de miss�o para rob�s: controle de miss�o � um sistema que permite ao
operador definir as miss�es de um ve�culo em linguagem de alto n�vel; prov�
ferramentas adequadas para converter planos em Progamas de Miss�es que podem
ser verificados e executados em tempo real; e permite ao operador saber o
estado da miss�o enquanto esta � executada, e modific�-la se for necess�rio. Em
\cite{brumitt1996dynamic}, o conceito de planejamento de miss�o � ampliado para
m�ltiplos rob�s: planejamento de miss�o � o processo de determinar o
que cada rob� deve fazer para alcan�ar os objetivos da miss�o, em um ambiente
din�mico. 

Neste trabalho, o controle de miss�o de rob�s � o componente da arquitetura
rob�tica que organiza e executa todas as tarefas do rob� de maneira �tima,
exerce o papel de traduzir os comandos de miss�o do usu�rio ao rob�, prov� feedback ao
operador, e cont�m as diretivas do rob�. Como faz parte da arquitetura, as
se��es que seguem buscam, em cada arquitetura, destacar de forma exemplificada
alguns controles de miss�o.

\section{Paradigma hier�rquico/deliberativa}
Em meados do s�culo XX, s�o realizados os primeiros estudos de rob�s aut�nomos,
juntamente com o aparecimento da Intelig�ncia Artificial (IA). Em um sistema
rob�tico, a IA cl�ssica consiste em um modelo centralizado que coleta
informa��es usando sensores, cria um modelo do ambiente, planeja o pr�ximo
movimento e executa a a��o. S�o sistemas do tipo \emph{Sense, Plan and
act} (SPA). Essa arquitetura de controle � cl�ssica e tem abordagem
\emph{top-down} (hier�rquica), como na decomposi��o tradicional da
figura~\ref{BROOKS_1}.
%TODO: Mudar essa figura

De acordo com Marvin Minsky, uma m�quina deveria tender a criar, por si s�, um
modelo abstrato do ambiente em que est� inserido (defina-se \emph{mundo}).
Caso fosse dado uma tarefa, ela primeiro poderia explorar solu��es dentro de seu modelo abstrato e, ent�o,
experiment�-las externamente. Seria como realizar uma simula��o interna
e, caso funcionasse, realiz�-la no mundo real.

\subsection{Rob�s deliberativos}
Entre 1966 e 1972, Charles Rosen e Nils Nisson da Universidade de Stanford
criaram o Shakey, primeiro rob� m�vel aut�nomo (figura~\ref{SHAKEY_1}). Foi
desenvolvida uma intelig�ncia artificial, \textit{problem solver}, chamada
STRIPS. Este sistema � um planejador de trajet�rias que armazena as imforma��es
do ambiente (mapas e obst�culos) de maneira simb�lica e, se dada uma tarefa de
deslocamento (\textit{goto}), � realizada uma busca l�gica pelo sistema.

Em 1977, come�ou a ser desenvolvido o projeto HILARE (figura~\ref{hilare}), no
Laboratoire d'Automatique et d'Analyse des Syst�mes (LAAS), Toulouse, France. Possu�a sensores como c�mera, quatorze ultrassons e laser para
medir dist�ncia, sendo poss�vel atualizar o seu mundo com acur�cia. Seu mundo
era representado por modelos geom�tricos e um modelo relacional que expressava a
conectividade dos quartos e corredores (simb�lico) \cite{norelis1989control}.

Tamb�m em 1977, o Stanford Cart foi criado por Moravec para teste de vis�o
para navega��o e desvio de obst�culos \cite{moravec1977towards}. Os obst�culos
eram identificados pelo rob� durante a opera��o e representados em seu mundo
como esferas. O mundo tamb�m era representado simbolicamente por grafos.

Em 1969, Victor Scheinman, Universidade de Stanford
\cite{scheinman1969design}, inventou o primeiro manipulador rob�tico
totalmente el�trico de seis elos e com solu��o completa e integrada de
cinem�tica inversa. Isto �, dado um ponto qualquer pertencente ao espa�o de
trabalho do manipulador, este calcula o �ngulo das juntas de forma que o
efetuador alcance o ponto especificado. Isso permitiu que o manipulador
percorresse trajet�rias arbitr�rias. At� os dias atuais, 2015, � ampla a
utiliza��o de manipuladores industriais. A sofistica��o destes sistemas j�
possibilita que estes armazenem todo o conhecimento do mundo e executem tarefas
aut�nomas (figura~\ref{manipulador}).

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/SHAKEY_1.png}
\caption{Shakey robot}
\label{SHAKEY_1}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/HILARE.png}
\caption{HILARE}
\label{hilare}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/MANIPULADOR.png}
\caption{Manipulador rob�tico atual}
\label{manipulador}
\end{figure}

\subsection{Arquiteturas deliberativas}
As arquiteturas deliberativas s�o sistemas hier�rquicos com a l�gica
\textit{SPA}. S�o utilizados em sistemas rob�ticos at� hoje, quando a aplica��o
favorece seu uso e devido ao grande poder computacional atual. Destacam-se os modelos de Albus,
NASREM, \textit{Nested Hierarchical Controllers} e o \emph{Intelligent Mobile
Robot System} de Saridis.

\subsubsection{Modelo de Albus}

Albus foi o pioneiro e mais influente autor de teorias em arquiteturas
deliberativas, que pode ser vista em \cite{albus1991outline}. Sua
grande contribui��o foi a formaliza��o e defini��o de diversos termos
amplamente utilizados em automa��o e controle. Dentre outros, destaca-se o
teorema de que h� quatro sistemas que comp�em a intelig�ncia: processamento de
sensores, modelo do mundo, gera��o de comportamentos e julgamento de valor. As
entradas desses elementos s�o os sensores e suas sa�das s�o os atuadores:

\begin{itemize}
  \item Atuadores: as sa�das de um sistema inteligente pe produzida por
  atuadores, como mover, posicionar bra�os, pernas, m�os, olhos e etc. Os
  atuadores naturais s�o os m�sculos e as gl�ndulas, j� os atuadores de m�quinas
  s�o motores, pist�es e v�lvulas.
  \item Sensores: s�o as entradas de um sistema inteligente, como sensores de
  for�a, torque, posi��o, velocidade, vibra��o, ac�stico, gases, temperatura e
  muitos outros. Monitoram o mundo e o estado interno do sistema, e prov� dados
  ao sistema de processamento sensorial.
  \item Processamento sensorial: sistema que compara novas observa��es com a
  expectativa interna do modelo do mundo. Integra e armazena as diferen�as e
  semelhan�as encontradas, a fim de reconhecer padr�es, objetos e rela��es no
  mundo.
  \item Modelo do mundo: � a melhor estimativa que o sistema inteligente possui
  do mundo, e atualizado pelo processamento sensorial. � um banco de dados com
  todo o conhecimento do mundo e cont�m uma capacidade de simula��o que gera expectativas e predi��es. O modelo do mundo
  pode prover informa��es do passado, presente e prev� estados futuros.
  Os dados s�o importantes para: o gerador de comportamentos escolher o plano
  adequado para execu��o das a��es; o processamento sensorial fazer correla��es,
  compara��o de modelos, e reconhecimento de objetos, estados e eventos; e o
  sistema de julgamento de valor computar valores de custo, benef�cio, risco,
  incerteza, import�ncia e outros.
  \item Julgamento de valor: este � o sistema que determina o que � bom ou ruim,
  importante ou trivial, certo ou improv�vel. Computa custos, riscos e
  benef�cios de situa��es observadas e atividades planejadas.
  \item Gerador de comportamentos: elemento que seleciona objetivos e planos,
  executa e monitora a��es, e modifica planos existentes quando alguma situa��o
  do mundo exigir. Tarefas s�o decompostas em subtarefas, e subtarefas s�o
  sequ�ncias de objetivos. A ordem l�gica de funcionamento �: o gerador de
  comportamentos cria planos, o modelo do mundo predita o resultado do plano, e
  o julgamento de valor avalia os resultados. O gerador de comportamento
  seleciona o plano com a avalia��o mais alta.
\end{itemize}
As rela��es entre os elementos do sistema inteligente est�o representados na
figura~\ref{albus}.  Esses elementos e suas rela��es possibilitaram a cria��o de
diversas arquiteturas.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/albus.pdf}
\caption{Arquitetura de Albus para sistemas deliberativos.}
\label{albus}
\end{figure}


\subsubsection{NASREM}
O NASREM \cite{albus1989nasa} foi uma arquitetura utilizada pela
NASA e possu�a uma arquitetura com seis n�veis de
funcionalidade(figura~\ref{nasrem}):

\begin{enumerate}
  \item Servo: prov� o controle dos atuadores do rob� (posi��o, velocidade e
  etc).
  \item Primitiva: determina as primitivas de movimento para gerar trajet�rias
  suaves.
  \item Movimento elementar: define e planeja trajet�rias livre de colis�es.
  \item Tarefa: converte a��es desejadas de um objeto em sequ�ncias de
  movimentos elementares.
  \item Compartimento de servi�os: converte a��es de grupos de objetos em
  tarefas de um objeto.
  \item Miss�o: decomp�e o plano de miss�o em alto n�vel em compartimento de
  servi�os.
\end{enumerate}

Vale ressaltar que no modelo NASREM, o operador tem acesso a qualquer n�vel
hier�rquico do rob� e pode tomar o controle do rob� para si, al�m de poder
substituir as entradas de sensores, modelo do mundo e outros. Dessa forma, o
n�vel de autonomia do rob� pode ser desenvolvido de forma incremental.

A arquitetura hier�rquica proposta em NASREM permite modularidade e prop�e uma
metodologia de software.  
 
\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/NASREM.pdf}
\caption{Arquitetura NASREM.}
\label{nasrem}
\end{figure}

\subsubsection{\textit{Nested Hierarchical Controllers}}
O \textit{Nested Hierarchical Controllers} (NHC) consiste tamb�m em seis
n�veis hier�rquicos: planejador da miss�o, navegador, piloto, monitor de
trajet�ria, controlador, e sistema de controle de baixo n�vel. H� tamb�m
constante atualiza��o do modelo do mundo por um sistema de sensoriamento.

O planejamento � decomposto em planejador da miss�o, navegador e piloto e seus
m�dulos s�o executados sequencialmente, tornando-se mais espec�fico e detalhado.
A l�gica � hier�rquica: o planejador de miss�o envia trechos da miss�o para o
navegador, o qual envia trechos de trajet�ria para o piloto, que determina a��es
ao controlador de baixo n�vel. A utiliza��o do mapa interno do rob� por cada
m�dulo � diferente, enquanto o planejador usa o mapa global, o piloto recebe
informa��es locais. Vale observar que, quando o modelo do mundo � atualizado,
muitas vezes n�o h� necessidade de o planejador atualizar toda a miss�o e
recome�ar o ciclo de planejamento, apenas o piloto pode recalcular a trajet�ria
local. 
%TODO: FIGURA 

\subsubsection{\textit{Intelligent Mobile Robot System}}
Em 1991, Saridis \cite{wang1991petri} cria o \emph{Intelligent Mobile
Robot System} (IMRS) baseado na teoria de intelig�ncia hier�rquica de controle
\cite{saridis1988analytical}. Saridis utiliza redes de Petri como m�dulos
b�sicos da arquitetura para traduzir os comandos gerados pelo n�vel de
organiza��o em algo compreens�vel para o n�vel de execu��o.

O IMRS possui a seguinte arquitetura (figura~\ref{Saridis_1}):
\begin{itemize}
  \item N�vel organizacional (organizador de tarefas): gera tarefas de
  movimenta��o de alto n�vel.
  \item N�vel de coordena��o: funciona como uma interface entre o n�vel
  organizacional e o de execu��o. O n�vel � composto por um remetente e alguns
  coordenadores. O remetente recebe o plano da tarefa do organizador, decomp�e a
  tarefa em a��es de controle e remete aos coordenadores. Os coordenadores
  traduzem os comandos de controle em instru��es de opera��o e transmite ao
  n�vel de execu��o.
  \item N�vel de execu��o: executa a instru��o proveniente do n�vel de
  coordena��o e reporta seus resultados a ele.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/SARIDIS_1.pdf}
\caption{IMRS}
\label{Saridis_1} 
\end{figure}

O n�vel de coordena��o do IMRS � composto por um remetente
(\emph{Dispatcher}) e tr�s coordenadores: sistema de vis�o (VS), desvio de
obst�culo e controle de rastreamento (OATC), e planejamento de trajet�rias (PP).
Com o modelo de redes de Petri n�o � poss�vel implementar o esquema de linguagem de
decis�o para descrever a tradu��o de tarefas entre remetente e coordenadores.
Portanto, os \emph{Petri Net Transducers} (PNTs) foram introduzidos como
tradutores de linguagem (protocolo): $PNT = (N,\Sigma,
\Delta, \sigma, \mu, F)$. Onde:
\begin{itemize}
	\item A rede de Petri $N=(P,T,I,O)$, $P$ lugares, $T$
transi��es, fun��o de entrada $I$, fun��o de sa�da $O$, � o controle da
tradu��o;
	\item $\mu$ � o estado inicial de $N$;
	\item $\Sigma$ � o alfabeto de entrada, representa tarefas de entradas;
	\item $\Delta$ � o alfabeto de sa�da, representa tarefas de sa�da; 
	\item $\sigma$ especifica, para uma dada tarefa de entrada, as transi��es em
$N$ e as subtarefas de sa�da que podem ser usadas na tarefa;
	\item $F$ � o estado final. Indica o fim da tradu��o da tarefa;
\end{itemize}    

Os quatro PNT's s�o combinados para realizarem a tradu��o de tarefas no N�vel
de Coordena��o: remetente, sistema de vis�o, desvio de obst�culo
e controle de rastreamento, e planejamento de trajet�rias. A
figura~\ref{Saridis_2} mostra o modelo de rede de Petri para o Remetente.
%Ser� brevemente descrito o componente Remetente (\emph{Dispatcher}) do modelo
% de N�vel de Coordena��o para melhor entendimento do PNT.

%Foram definidas quatro tarefas para o N�vel de Coordena��o: 1) \emph{wmu}:
%atualiza��o da mem�ria 3-D do ambiente; 2) \emph{mod}: detec��o de objetos em
%movimento; 3) \emph{pp}: planejamento de trajet�rias; 4) \emph{moac}: desvio de
%obst�culos e controle de rastreamento. A figura~\ref{Saridis_2} mostra o modelo
%de rede de Petri para o Remetente.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth,angle=90]{figs/SARIDIS_2.pdf}
\caption{Estrutura do n�vel de coordena��o com foco na rede de Petri do
Remetente}
\label{Saridis_2}
\end{figure}

A modelagem do sistema utilizando redes de Petri proporcionaram, como pode ser
visto na figura~\ref{Saridis_2}, algumas funcionalidades essenciais em uma
arquitetura rob�tica: a capacidade de executar duas tarefas simultaneamente, por
exemplo, movimenta��o e planejamento de trajet�rias; e o \emph{Input Semaphore},
que impede um processo de ser executado at� outro ser finalizado.
  
% 
% 
% O estado inicial da rede de Petri �: $$M
% =\{2,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$, cujos lugares s�o: $$M
% =\{P_0,P_1,P_2,P_3,P_4,P_5,P_6,P_7,P_8,I_{PP},IS_{PP},\ldots$$
% $$OS_{PP},O_{PP},I_{VS},IS_{VS},OS_{VS},
% O_{VS},I_{OATC},IS_{OATC},OS_{OATC},O_{OATC}\}$$ 
% As suas transi��es s�o:
% \begin{enumerate}
%   \item A transi��o $t_s$ inicializa o Remetente quando uma tarefa � recebida
%   do Organizador. 
%   $$M=\{1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$  
%   O lugar $P_0$ permanece com um token, logo a transi��o $t_s$ ainda pode ser
%   disparada. Isso faz com que o Remetente seja capaz de executar duas tarefas
%   simultaneamente: a tarefa de movimenta��o (ver item 7) e o planejamento de
%   trajet�rias (ver item 3).
%   \item A transi��o $t_{wmu}$ chama o processo de atualiza��o do mapa 3-D. O
%   sistema de vis�o poder� ser iniciado (token em $I_{VS}$) e a transi��o
%   $t_{wmu}$ n�o pode ser disparada novamente at� completar mais um ciclo de
%   vis�o, gra�as ao \emph{Input Semaphore}, $IS_{VS}$.
%   $$M=\{1,0,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,1,1,0\}$$
%   Ao fim do ciclo do sistema de vis�o, o seu \emph{Output Point}, $O_{VS}$,
%   adquire um token, habilitando a transi��o $t_{PP}$ do Remetente. 
%   $$M=\{1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,1,1,0\}$$
%   Vale observar que n�o � poss�vel modelar essas caracter�sticas com m�quinas de
%   estado sem a utiliza��o de recursos extras como inibidores e supressores.
%   \item A transi��o $t_{pp}$ habilita o planejamento de trajet�rias (token em
%   $I_{PP}$), com restri��es de espa�o, cinem�tica, din�mica e crit�rio de
%   otimiza��o. $t_{pp}$ n�o pode ser disparada novamente at� completar um
%   ciclo de planejamento de trajet�rias, gra�as ao \emph{Input Semaphore},
%   $IS_{PP}$.
%   $$M=\{1,0,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0\}$$
%   Ao fim do ciclo do planejamento de trajet�rias, o seu \emph{Output
%   Point}, $O_{PP}$, adquire um token, habilitando a transi��o $t_{ssd}$ do
%   Remetente.
%   $$M=\{1,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,1,0\}$$
%   \item A transi��o $t_{ssd}$ � disparada para colocar o estado do planejamento
%   de trajet�rias no valor inicial:
%   $$M=\{1,0,0,0,1,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$
%   \item A transi��o $t_{mod}$ � disparada para o desvio de obst�culo em um
%   espa�o especificado e prov� acur�cia e tempo requerido. O
%   sistema de vis�o poder� ser iniciado novamente (token em $I_{VS}$) e a
%   transi��o $t_{mod}$ n�o pode ser disparada novamente at� completar mais um
%   ciclo de vis�o, gra�as ao \emph{Input Semaphore}, $IS_{VS}$.
%   $$M=\{1,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,1,0\}$$
%   Ao fim do ciclo do sistema de vis�o, o seu \emph{Output Point}, $O_{VS}$,
%   adquire um token, habilitando a transi��o $t_{moac}$ do Remetente. 
%   $$M=\{1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,0,1,1,0\}$$
%   \item A transi��o $t_{moac}$ � disparada e habilita o desvio de obst�culo
%   e controle de rastreamento (token em $I_{OATC}$). O estado do sistema de vis�o volta para
%   o valor inicial e $t_{moac}$ n�o pode ser disparada novamente at� completar um
%   ciclo de desvio de obst�culo, gra�as ao \emph{Input Semaphore}, $IS_{OATC}$.
%   $$M=\{1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,1,0,1,0\}$$
%   Ao fim do ciclo do desvio de obst�culo, o seu \emph{Output
%   Point}, $O_{OATC}$, adquire um token, habilitando a transi��o $t_{mte}$ do
%   Remetente.
%   $$M=\{1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1\}$$
%   \item A transi��o $t_{mte}$ realiza a tarefa de movimenta��o do rob�. O
%   sistema de desvio de obst�culos e controle de rastreamento volta para o estado
%   inicial.
%   $$M=\{1,0,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$
%   Caso haja falha, as transi��es $t_{cmo}$ ou $t_{cmn}$ podem ser disparadas.
%   \item A transi��o $t_{fbo}$ dispara para o envio de \emph{feedbacks} ao
%   Organizador.
%   $$M=\{1,0,0,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,1,0\}$$
%   \item A transi��o $t_{cmn}$ � disparada em caso de falha na movimenta��o do
%   rob�. O rob� continuar� o seu movimento por um novo caminho. Volta ao item 2.
%   $$M=\{1,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$ 
%   \item A transi��o $t_{cmo}$ � disparada em caso de falha na movimenta��o do
%   rob�. O rob� continuar� o seu movimento pelo mesmo caminho. Volta ao item 5.
%   $$M=\{1,0,0,0,1,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$
%   \item A transi��o $t_f$ dispara para reportar o resultado da movimenta��o do
%   rob� ao Organizador. Volta ao item 1.
%   $$M=\{2,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0\}$$ 
% \end{enumerate} 

%A rede de Petri evidencia o motivo do uso dos PNT, com os par�metros aumentados
%$PNT = (N,\Sigma, \Delta, \sigma, \mu, F)$. %At� agora, apenas as vari�veis
%diretamente ligadas � rede: $N$ e $\mu$ foram analisadas, mas quando se busca a
%Quando se busca a integra��o das redes dos coordenadores fica n�tida a
% necessidade de par�metros para especifica��o das tarefas.

%O alfabeto de entrada do Remetente � dado pelo Organizador, dado como
%$\Sigma_0$. O alfabeto de sa�da ($\Delta_0$) s�o os alfabetos de entrada para
%cada coordenador (PP, VS e OATC): $\Sigma_p = \{path\}$,
%$\Sigma_m=\{\textrm{freemove}, \textrm{move}\}$ e
%$\Sigma_v=\{\textrm{sendinfo.detection}, \textrm{terrain}\}$.

%O par�metro que especifica as transi��es para uma determinada tarefa e as
%subtarefas � o $\sigma$. Para a transi��o $t_{mod}$, por exemplo,
%$\sigma(t_{mod},mod)=\{\textrm{detection.sendinfo}(ard_i,ptc_i),
%\textrm{sendinfo}(ard_i,ptc_i)\}$, onde $ard$ � a acur�cia requerida sobre
%objetos detectados em VS e $ptc$ � o tempo para a realiza��o do processo. A
% rede de Petri no coordenador VS pode, portanto, assumir transi��es paralelas (dois
%caminhos) e o que define qual caminho deve ser seguido � o par�metro do
%Remetente (neste caso ser� a transi��o $t_{smd}$ de VS).

Saridis salienta os benef�cios das PNT:
\begin{itemize}
  \item Redes de Petri podem ser usadas como m�dulos b�sicos para sistemas de
  controle de miss�o de rob�s m�veis.
  \item A comunica��o e conex�o de m�dulos s�o eficientes entre redes de Petri.
  \item Controle e mecanismo de comunica��o para coordena��o de tarefas de um
  rob� m�vel podem ser realizados com redes de Petri.
\end{itemize} 

A arquitetura de Saridis � uma contribui��o importante por criar um n�vel
organizacional, separando o n�vel do desenvolvedor de baixo n�vel e um
n�vel de alto n�vel para um operador (usu�rio). Al�m disso, as redes de Petri
assumem um importante papel como m�dulo b�sico de controle para seu sistema
IMRS. As redes de Petri foram originalmente introduzidas para descrever as
comunica��es de m�quinas de estado finito (FSM), possibilitando flexibilidade
e robustez, e � provado que redes de Petri s�o excelente ferramenta para
modelagem de sistemas, sobretudo quando envolvem tarefas conflitantes ou
simult�neas, Murata \cite{murata1989petri}.


\subsection{An�lise cr�tica}
A abordagem deliberativa simula, de certa forma, o processo de planejamento e
tomada de decis�o do ser humano. H� um n�cleo (c�rebro) que
processa todos os dados sensorias e armazena o mundo, isto �, o ambiente em que
est� inserido, de maneira simb�lica, geom�trica ou outras.
Al�m disso, ele planeja todas as a��es para uma determinada tarefa, consultando sua ideia de mundo intensivamente. H�,
tamb�m, sensores que enviam suas novas informa��es periodicamente para o n�cleo,
(�rg�os receptivos: vis�o, olfato, e etc), atualizando o mundo. E h�
atuadores (m�sculos) necess�rios para a realiza��o das tarefas~\ref{brain}.

� f�cil observar que a arquitetura deliberativa � dependente do
modelo de mundo armazenado e suas atualiza��es peri�dicas. Portanto, a
utiliza��o da abordagem deliberativa em ambientes extremamente din�micos pode ser muito
custosa devido �s atualiza��es e ao replanejamento. Al�m disso, � f�cil observar
que a arquitetura SPA dificulta a cria��o de sistemas em tempo real eficientes.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/BRAIN.png}
\caption{Comparativo da arquitetura deliberativa com o ser humano.}
\label{brain}
\end{figure}

\section{Paradigma reativo}

Sistemas de arquitetura reativa tamb�m s�o chamados de sistemas baseados em
comportamentos. Os rob�s s�o programados para agir atrav�s de ativa��o de uma
cole��o de comportamentos primitivos de baixo n�vel. De acordo com
\cite{arkin1995reactive}, as principais caracter�sticas de sistemas puramente
reativos s�o:

\begin{itemize}
  \item Comportamentos s�o como elementos construtivos: s�o um par sensor-motor,
  onde o sensor prov� informa��o necess�ria para o motor executar uma a��o
  reativa, como desvio de obst�culo, atrair-se a objetivos, escapar de
  predadores e etc.
  \item N�o h� cria��o ou manuten��o precisa do modelo do mundo. Os sistemas
  reagem ao est�mulo do mundo, extremamente �til para mundos din�micos e
  hostis.
  \item Comportamentos de animais s�o normalmente utilizados para modelar esses
  sistemas.
\end{itemize}

Dessa forma, controle reativo � uma t�cnica que une percep��o e a��o,
tipicamente no contexto de comportamentos motores, para produzir respostas
rob�ticas em tempo real em mundos din�micos e n�o estruturados.

Em 1986, um dos primeiros estudos em sistemas reativos foi desenvolvido por
Rodney Brooks \cite{brooks1986robust}. Este estudo � a base para diversos
trabalhos atuais que envolvem rob�s reativos m�veis. Os desafios de
rob�s aut�nomos apontados por Brooks e que ainda ilustram os problemas da
atualidade s�o: \emph{m�ltiplos objetivos}, \emph{m�ltiplos sensores},
\emph{robustez} e \emph{extensibilidade}. De acordo com Brooks, esses desafios
n�o s�o suportados pela arquitetura tradicional (paradigma hier�rquico) de um
sistema de controle.

Os m�ltiplos objetivos de rob�s m�veis podem:
\begin{itemize}
  \item Ser conflitantes: por exemplo, um rob� pode estar tentando alcan�ar um
  determinado ponto no espa�o, por�m evitando obst�culos locais.
  \item Ter rela��es de prioridade: por exemplo, um rob� que inspeciona trilhos
  de tr�m deve sair dos trilhos ao ouvir o sinal de um tr�m chegando, mesmo se estiver
  finalizando a opera��o.
  \item Ser denpendentes: objetivos de \emph{alto n�vel} englobam diversos
  objetivos de \emph{baixo n�vel}. No caso do exemplo acima, o rob� que sai do
  trilho para evitar o tr�m deve se manter equilibrado para n�o cair. Artigos
  recentes, como em \cite{fryxell1996navigation} separam esses objetivos em
  \emph{tarefas} (objetivos de \emph{alto n�vel}) e \emph{primitivas do ve�culo}.
\end{itemize}

Rob�s s�o normalmente providos de m�ltiplos sensores e suas diversas
informa��es podem ser redundantes, conflitantes ou complementares,
podendo ser utilizadas para uma mesma tarefa do rob�.
Por exemplo, encoders para odometria e c�meras fixas ao rob�
podem ser utilizados para localiza��o, de forma que se complementem.
Os sensores podem apresentar erros ou resultados conflitantes, portanto a fus�o
da informa��o de m�ltiplos sensores, a determina��o de seus graus de
confiabilidade e em quais tarefas devem ser considerados s�o decis�es que o
rob� deve saber fazer.

Um rob� deve ser robusto, isto �, em caso de falha de um sensor, o rob�
deve se adaptar e utilizar os outros sensores que ainda funcionam para realizar as
tarefas. Ou em caso de altera��es no ambiente, o rob� deve ser
capaz de cumprir determinadas fun��es essenciais.

A extensibilidade constitui em acrescentar mais sensores e,
portanto, aumentar a capacidade do rob�, sendo poss�vel a execu��o de novas
tarefas. Por�m, existe um limite imposto pela limita��o
de processamento do rob�, j� que um novo hardware (sensor) � adicionado, mas o
processamento (computador) n�o � substitu�do e sua capacidade n�o � aumentada.

Brooks prop�e um dos primeiros sistemas baseados em comportamentos, uma
arquitetura que tem como objetivo descentralizar a tomada de decis�o de um
modelo central, como pode ser visto na figura~\ref{BROOKS_1}. O autor comenta
que essa decomposi��o conduz a uma arquitetura radicalmente diferente para
sistema de controle de rob�s m�veis em estrat�gias de implementa��o a n�vel de
hardware e com grandes vantagens em robustez, desenvolvimento e teste.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_1.pdf}
\caption{Arquitetura para sistema de controle de rob�s m�veis por Brooks}
\label{BROOKS_1}
\end{figure}

\subsection{Rob�s reativos}
Antes mesmo de Brooks, ou seja, da formaliza��o de toda a teoria em sistemas
reativos, simples rob�s eram criados na l�gica de controle reativo e de
comportamentos. Em 1953, por exemplo, Grey Walter \cite{holland1997grey}
desenvolveu uma ``tartaruga'' el�trica capaz de se movimentar pelo ambiente,
evitando luz intensa (``amea�as'') e atra�da por certos objetivos. Vale
observar a caracter�stica do rob� de perceber baixo n�vel de bateria e procurar
uma esta��o de recarga, comportamento que se sobrep�e aos outros. Os
comportamentos s�o simples e n�o h� representa��o abstrata do mundo:
dirigir-se para luz fraca; fugir de luz forte; e evitar obst�culos.

Em 1984, ve�culos simples e puramente reativos com os pares cl�ssicos
sensor-motor foram desenvolvidos pelo psicologista Braitenberg
\cite{braitenberg1986vehicles}, a fim de simular sentimentos, como covardia,
agressividade e outros. 

Em 2002 at� os dias atuais, o rob� iRobot Roomba ganha destaque comercial e
executa uma simples tarefa dom�stica: limpar o ch�o. Em sua arquitetura, o rob�
Roomba possui apenas algumas fun��es reativas, como esquivar-se e locomover-se,
e, em suas vers�es antigas, foi constatado que n�o possui o modelo do mundo,
mapa, dentro de si \cite{tribelhorn2007evaluating}.

\subsection{Arquiteturas reativas}


\subsubsection{Arquitetura de subsun��o}
Na figura~\ref{BROOKS_1}, o autor define \emph{N�veis de compet�ncia}, que s�o
classes de comportamentos desejados para o rob� sobre todos os ambientes que ele
pode encontrar. As classes definidas por Brooks s�o:
\begin{enumerate}
\setcounter{enumi}{-1}
  \item Evitar contato com objetos (estacion�rios ou m�veis);
  \item Vaguear sem rumo e sem bater em objetos;
  \item Explorar o ambiente utilizando sensores e definir lugares alcan��veis.
  Seguir rumo em sua dire��o;
  \item Construir um mapa do ambiente e planejar trajet�rias de um lugar para
  outro;
  \item Observar mudan�as no ambiente;
  \item Raciocinar sobre o ambiente em termos de objetos identific�veis e
  realizar tarefas relacionadas a certos objetos;
  \item Formular e executar planos que envolvam mudar o estado do ambiente como
  desejado;
  \item Raciocinar sobre o comportamento de objetos no ambiente e modificar
  planos quando necess�rio;
\end{enumerate}

Vale observar que cada n�vel de compet�ncia inclui, como subconjunto, os
n�veis de compet�ncia anteriores.

Ap�s a decomposi��o na nova arquitetura, Brooks define as \emph{Camadas de
Controle}, correspondentes a cada n�vel de compet�ncia. A ideia dessa abordagem
� adicionar camadas de controle a n�veis de compet�ncias superiores sem precisar
alterar a camada do n�vel inferior. Inicia-se, portanto, com a camada de
controle para o n�vel zero de compet�ncia, esta ser� testada e n�o mais
alterada. Ap�s, � criada a camanda de n�vel 1, capaz de examinar os dados
da camada de n�vel 0 e injetar dados nas interfaces internas deste n�vel,
suprimindo seu tr�nsito de dados, figura~\ref{BROOKS_2}.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_2.pdf}
\caption{Camadas de controle de Brooks}
\label{BROOKS_2}
\end{figure}

Os problemas apresentados por Brooks s�o solucionados pela nova arquitetura:
\begin{itemize}
  \item M�ltiplos objetivos: camadas individuais podem trabalhar em objetivos
  individuais ao mesmo tempo. Os n�veis das camadas de controle e o mecanismo de
  supress�o do tr�nsito de dados resolvem os problemas de conflito, depend�ncia
  e prioridade;
  \item M�ltiplos sensores: as camadas utilizam os dados dos sensores
  independentemente, de forma que n�o h� necessidade de se preocupar com a
  fus�o;
  \item Robustez: al�m do uso inteligente de sensores, camadas de controle de
  n�vel inferior continuam a funcionar quando novas camadas de n�vel superior
  s�o adicionadas;
  \item Extensibilidade: cada camada de controle pode possuir o seu pr�prio
  processador; 
\end{itemize}

A estrutura das camadas de controle foram constru�das por um conjunto de
pequenos processadores que enviam mensagens uns para os outros. Cada processador
� uma m�quina de estado finito. A nova arquitetura e essa nova estrutura de
camadas com eventos discretos foram a base de diversos sistemas de controle de
miss�o da atualidade. A fim de melhorar o entendimento desse sistema criado
por Brooks, ser�o apresentados dois n�veis de seu controle em uma aplica��o de rob�
m�vel.

A camada de controle n�vel zero deve garantir que o rob� n�o entre em contato
com outros objetos, estacion�rios ou m�veis. Portanto, o rob� deve desviar de
objetos que se aproximam ou parar se houver um objeto fixo em sua trajet�ria.
Na figura~\ref{BROOKS_3}, podemos observar o n�vel 0 de controle do sistema.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_3.pdf}
\caption{N�vel 0 de controle do sistema}
\label{BROOKS_3}
\end{figure}

Segue pequena descri��o de cada m�dulo:
\begin{itemize}
  \item M�dulo \emph{Curva}: comunica-se diretamente com o rob� (atuadores).
  Recebe uma mensagem \emph{Dirigir} especificando um �ngulo de giro seguido por
  uma mensagem do m�dulo \emph{Avan�o} com uma determinada magnitude. Isso faz
  com que o rob� realize uma curva e v� para o estado de \emph{Avan�o}.
  \item M�dulo \emph{Avan�o}: comando faz rob� se movimentar (atuadores), mas
  p�ra o rob� se receber mensagem do m�dulo \emph{Colis�o}. O rob� fica inativo
  e mensagens do encoder � enviado ao m�dulo \emph{Curva}, funcionando como um
  \emph{reset}, e podendo receber novos comandos.
  \item M�dulo \emph{Sonar}: recebe um vetor de informa��es de sensores do rob�,
  filtra os dados e produz um mapeamento de obst�culos para o rob� em
  coordenadas polares.
  \item M�dulo \emph{Colis�o}: monitora o mapa gerado pelo m�dulo \emph{Sonar}
  e, se detectar um obst�culo, envia um sinal de parada. Observe que este m�dulo
  funciona independentemente se o rob� est� em movimento ou parado.
  \item M�dulo \emph{Sentir For�a}: cada obst�culo detectado � somado
  como uma for�a repulsiva, gerando uma for�a resultante.
  \item M�dulo \emph{Fugir}: monitora a for�a produzida pelos obst�culos e envia
  comandos para o m�dulo \emph{Curva} se a for�a for significante.
\end{itemize}
 
 A camada de controle n�vel 1, combinada a camada de controle n�vel 0, permite
 que o rob� vagueie sem colis�es. A figura~\ref{BROOKS_3} mostra o sistema de
 controle aumentado pelo n�vel da camada 1.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_4.pdf}
\caption{N�vel 0 e 1 de controle do sistema}
\label{BROOKS_4}
\end{figure}

Segue pequena descri��o de cada m�dulo do n�vel 1:
\begin{itemize}
  \item M�dulo \emph{Vaguear}: gera nova dire��o para o rob� a cada 20 segundos.
  \item M�dulo \emph{Evitar}: recebe resultado da for�a computada pelo n�vel 0
  de controle e combina com a dire��o desejada pelo m�dulo \emph{Vaguear},
  produzindo uma nova dire��o desejada sem obst�culos. Esse resultado presume as
  computa��es do m�dulo \emph{Fugir}. Vale observar que o m�dulo \emph{Evitar}
  suprime a sa�da do m�dulo \emph{Fugir} (mecanismo de supress�o). 
\end{itemize}

A nova arquitetura de Brooks � robusta, permite intera��es din�micas, � flex�vel
para integrar novas funcionalidades e f�cil para implementar e debugar. Brooks
ainda associa sistemas de eventos discretos no controle de rob�s aut�nomos,
utilizando como m�dulos b�sicos m�quinas de estados finitos (FSM - \emph{Finite
State Machine}). Como a conex�o de diversas FSM's n�o � uma FSM, a solu��o
encontrada por Brooks foi acrescentar inibidores e supressores em suas
FSM, chamando-as AFSM (\emph{Augmented Finite State Machine} ou m�quina de
estado aumentada). O m�dulo principal desta arquitetura pode ser visto na FIGURA
%TODO Colocar figura de brooks 



Antes de Brooks, em 1983, Elfes, A. \cite{elfes1983distributed},j� havia
idealizado uma arquitetura em m�dulos e controle distribu�do a fim de atingir efetividade em processamento
paralelo, flexibilidade de intera��o com os diversos sensores, distribuir
capacidades de decis�o e flexibilidade de expans�o e modifica��o do sistema.
Por�m o sistema de comunica��o entre m�dulos era centralizado
(\emph{Blackboard}) e s� realizavam uma determinada tarefa sob o comando de um
Plano de Controle (\emph{Control Plan}). O usu�rio ainda deveria explicitamente
codificiar paralelismo, os casos das exce��es e condi��es inesperadas.

Apesar dos pontos positivos, a arquitetura de controle de um sistema
baseado em comportamento apresenta problemas com escala e contextualiza��o
(\emph{situatedness}). 

O problema com escala � resultado das interconex�es, que
podem crescer de maneira fatorial em rela��o ao n�mero de comportamentos. 
A contextualiza��o � um problema de sistemas de subsun��o, onde subsistemas s�o
inclu�dos em um sistema mais amplo. Como cada comportamento � uma FSM, operando
concorrentemente com as outras, o comportamento corrente � o �nico estado no
qual o ve�culo como um todo funcionar�. S�o sistemas tamb�m chamados de
\emph{non-taskable systems} - uma tarefa n�o pode ser designada ao
ve�culo sem reprograma��o de todo o sistema.  

Apenas em 1996, Bellingham e Consi \cite{bellingham1994second}
propuseram um controle por camadas (\emph{Layered Control}) a fim de resolver o
problema de escala. A diferen�a entre o controle baseado em comportamento e o de
Bellingham � a restri��o de interatividade entre camadas.

As camadas (que s�o referenciadas como comportamentos) s�o associadas com um n�mero de
prioridade, de forma que sa�das conflitantes s�o resolvidas com esse n�mero. H�
um m�dulo de processamento de sensores que disponibiliza os dados aos
comportamentos, como o \emph{Blackboard}, o que viola a premissa de
paralelismo, mas resolve o problema de interconex�es, j� que antes as camadas
superiores deveriam se conectar �s inferiores para obter os dados dos sensores.

A solu��o para o problema de contextualidade s� foi resolvido em 2000 por Bennet
\cite{bennett2000behavior}. No \emph{State Configured Layered Control} (SCLC),
m�ltiplos conjuntos de comportamentos simples s�o escolhidos de uma biblioteca
de comportamentos e s�o executados em cada fase da miss�o. A vantagem � o
n�mero reduzido de comportamentos sendo executados ao mesmo tempo. Veremos mais
a frente que esta estrat�gia � muito realizada em controle h�brido.

% Em 1989, Chatila \cite{norelis1989control} descreve uma nova arquitetura e
% sistema de controle utilizando, assim como Brooks, m�dulos hier�rquicos. A
% arquitetura do rob� pode ser decomposta da seguinte forma:
% \begin{itemize}
%   \item \textbf{M�dulos de sensores}: processam as sa�das dos sensores. Os dados
%   adquiridos por um sensor s�o processados pelo m�dulo de sensor e ficam
%   dispon�veis para os m�dulos de n�vel mais alto para seus pr�prios
%   processamentos e interpreta��s.
%   \item \textbf{Unidades funcionais}: realizam uma determinada fun��o no rob�.
%   Por exemplo, localiza��o do rob� combinando sensores de vis�o, odometria, laser e
%   etc.
%   \item \textbf{Processos}: realiza a din�mica de malha fechada entre percep��o
%   e a��o, usando unidades de fun��o. O processo � representado por uma m�quina de estado
%   finito, onde suas entradas s�o os dados dos m�dulos dos sensores e suas sa�das
%   s�o comandos aos atuadores.
% \end{itemize}
% 
% O sistema de controle de Chatila � composto por quatro componentes: Supervisor
% (n�o implementado), M�dulo Executivo, Gerente de Vigil�ncia e M�dulo de
% Diagn�stico (n�o implementado). Os controles funcionam como um \emph{if - then},
% com diversas condi��es e a��es predeterminadas. O m�dulo de vigil�ncia �
% respons�vel por:
% 
% \begin{itemize}
%   \item Indicar estados dos sensores e tomar a��es de reflexo;
%   \item Indicar estado operacional do rob�, como n�vel da bateria;
%   \item Relatar plano e estado da miss�o que est� sendo executada pelo rob�;
% \end{itemize}
% 
% O m�dulo executivo fucniona como um sistema operacional. Recebe comandos
% (miss�es) predefinidas pela interface e se comunica com o m�dulo de vigil�ncia.
% 
% Quando comparamos com Brooks, Chatila apresenta uma estrutura bem
% rudimentar e l�gicas simples de arquitetura e controle. Apesar de utilizar a
% ideia de recursos compartilhados nos m�dulos de sensores, os automatos dos
% m�dulos de processo s�o bem simplificados e dependentes de um bloco central
% para resolver objetivos conflitantes.

\subsection{An�lise cr�tica}
Se a abordagem deliberativa simulava o processo de planejamento e tomada de
decis�o do ser humano, os sistemas de arquitetura reativa simulam outra
importante fun��o da medula espinhal, pertencente ao nosso sistema nervoso
central: o circuito reflexivo, ou arco reflexo. O reflexo � uma resposta
involunt�ria r�pida, consciente ou n�o, originado de um est�mulo externo e
realizada antes mesmo de o c�rebro tomar conhecimento do est�mulo perif�rico.



Dessa forma, n�o h� planejamento,  H� um n�cleo (c�rebro) que processa todos os
dados sensorias e armazena o mundo, isto �, o ambiente em que est� inserido, de maneira simb�lica, geom�trica ou outras.
Al�m disso, ele planeja todas as a��es para uma determinada tarefa, consultando sua ideia de mundo intensivamente. H�,
tamb�m, sensores que enviam suas novas informa��es periodicamente para o n�cleo,
(�rg�os receptivos: vis�o, olfato, e etc), atualizando o mundo. E h�
atuadores (m�sculos) necess�rios para a realiza��o das tarefas~\ref{brain}.

� f�cil observar que a arquitetura deliberativa � dependente do
modelo de mundo armazenado e suas atualiza��es peri�dicas. Portanto, a
utiliza��o da abordagem deliberativa em ambientes extremamente din�micos pode ser muito
custosa devido �s atualiza��es e ao replanejamento. Al�m disso, � f�cil observar
que a arquitetura SPA dificulta a cria��o de sistemas em tempo real eficientes.

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/BRAIN.png}
\caption{Comparativo da arquitetura deliberativa com o ser humano.}
\label{brain}
\end{figure}


\section{Arquitetura h�brida deliberativa/reativa}



A partir de 1995, os autores come�am a introduzir formalismo e terminologias
para os sistemas que visam o controle de miss�o de rob�s. 

Em 1995, Espiau, B. [9] (INRIA, Fran�a), define sistemas h�bridos como sistemas
que nem s�o puramente tempo cont�nuo, nem m�quina de estado finito, mas que
combinam eventos discretos e componentes cont�nuos. Esses sistemas foram
estudados por duas comunidades distintas: ci�ncia da computa��o e controle e
automa��o. Engenheiros de controle e automa��o estudam sistemas din�micos
(modelos) com �nfase nas teorias de estabilidade, converg�ncia, robustez e
introduzem sistemas de eventos discretos para mudan�as no controle ou no modelo.
A ci�ncia da computa��o faz o caminho inverso: um estado em uma m�quina de
estados representa um local de controle, onde vari�veis mudam continuamente com
o tempo, de acordo com leis de evolu��o. As ideias de controle h�brido s�o
desenvolvidas desde Brooks e aparece, mesmo que de forma rudimentar, nos
trabalhos apresentados anteriormente neste documento. 

A contribui��o de Espiau foi o desenvolvimento do ORCCAD, um sistema h�brido
para especifica��o, valida��o, simula��o e implementa��o de aplica��es
rob�ticas. O sistema possui os seguintes princ�pios:

\begin{itemize}
  \item Tarefas f�sicas podem ser tratadas como problemas de controle, os quais
  s�o resolvidos em tempo real utilizando t�cnicas de realimenta��o em controle.
  A abordagem \emph{Task-Function} foi desenvolvida em [10].
  \item A caracteriza��o de uma a��o f�sica n�o � suficiente para definir
  completamente a a��o de um rob�: tempo inicial e final devem ser considerados,
  assim como as a��es que o rob� deve tomar em caso de eventos observados
  durante a execu��o de alguma tarefa.
  \item Como a performance de um sistema depende da efici�ncia de mecanismos em
  tempo real no n�vel de opera��o, deve-se ter aten��o particular em sua
  especifica��o e verifica��o.
\end{itemize}

No sistema h�brido, o interesse do usu�rio final � em sua aplica��o, portanto
o sistema deve prover formalismo de alto n�vel para o usu�rio focar em
especifica��o e verifica��o de tarefas. Por outro lado, o engenheiro
de controle necessitar� de um ambiente de programa��o, desenvolvimento e
simula��o para expressar suas leis de controle, as quais s�o encapsuladas para
o usu�rio final. No ORCCAD, duas entidades foram definidas: Tarefa do Rob� (RT
- \emph{Robot-task}) e Processo do Rob� (RP - \emph{Robot Procedures}), as
quais est�o respectivamente ligadas aos dois tipos de usu�rios.

A Tarefa do Rob� � definida como a especifica��o param�trica de uma lei de
controle elementar, i.e., a ativa��o de um esquema de controle invariante ao
longo de uma tarefa, e um comportamento l�gico associado com um conjunto de
sinais (eventos) que podem ocorrer antes, durante ou ap�s a execu��o da tarefa.
A RT � composta por fun��es, modelos e par�metros que aparecem em uma express�o
anal�tica, em tempo cont�nuo, que ser� aplicada aos atuadores do rob� para a
execu��o de determinada a��o f�sica, e o comportamento l�gico associado aos
eventos, os quais podem ser:

\begin{itemize}
  \item Pr�-condi��es: ocorr�ncia necess�ria para a tarefa come�ar, como
  condi��es de sincroniza��o ou medida de sensores.
  \item Exce��es: executadas durante a execu��o da tarefa e pode indicar falha.
  A a��o tomada pode ser altera��o de algum par�metro, acionar outra RT
  (matando a atual) ou fatal, levando o rob� a uma �rea segura.
  \item P�s-condi��o: normalmente associadas ao ambiente (final do curso do
  rob�). 
\end{itemize}

O Processo do Rob� especifica de forma estruturada um arranjo l�gico e temporal
de RTs de forma que um determinado objetivo seja alcan�ado.

O sistema ORCCAD foi utilizado no rob� submarino Vortex, em conjunto com o
IFREMER \emph{Subsea Robotics Laboratory}.

Em 1996, Healey, A. J. [8] (Autonomous Underwater Vehicle Laboratory,
California), aplica t�cnicas de controle h�brido em seu trabalho de
desenvolvimento do AUV Phoenix.  � a partir de Healey
que s�o criados formalismo e terminologia apropriados nesse campo. O
controle h�brido ser� respons�vel tanto pela movimenta��o do ve�culo, cont�nuo
e s�ncrono, quanto pela sequ�ncia l�gica das fases das miss�es, eventos
discreto com transi��es ass�ncronas.  

Haley prop�e uma arquitetura de software h�brida com tr�s n�veis organizacionais
e hier�rquicos, figura~\ref{HEALEY_1}: 
\begin{itemize}
  \item \textbf{Estrat�gico}: utiliza Prolog como linguagem de controle de
  miss�o. Desenvolve os comandos que levam o ve�culo a executar determinada
  miss�o.
  \item \textbf{T�tico}: fun��es na linguagem C que faz interface com os
  predicados de Prolog e retorna \emph{TRUE / FALSE}. Este n�vel funciona de
  maneira ass�ncrona e ret�m os dados da miss�o, al�m de se comunicar com o
  n�vel de execu��o.
  \item \textbf{Operacional}: comanda os subsistemas do ve�culo a ativar fun��es
  de controle relacionadas ao n�vel t�tico.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/HEALEY_1.pdf}
\caption{Arquitetura do Rob� Phoenix de Healey}
\label{HEALEY_1}
\end{figure}

A terminologia de Healey, essencial para os trabalhos futuros em controle de
miss�o, � apresentada a seguir. Assumindo o conjunto de todos os atuadores
dispon�veis no ve�culo como $A$, o conjunto de sensores como $S$ e o conjunto de estados
cont�nuos como $X$:

\textbf{Defini��o}: Uma Fun��o de Controle (CF) � o uso de um subconjunto
espec�fico de atuadores $a_i \subset A$ com um subconjunto particular de
sensores $s_i \subset S$ para estimar um subconjunto de estados cont�nuos $x_i
\subset X$ e levar um certo subconjunto de erros $e_i$ para zero. Onde erro �
definido como a diferen�a entre um valor de comando (\emph{Set Point}) e um
estado atual estimado. A defini��o � an�loga com a defini��o de Tarefa do Rob�
(\emph{Robot Task}), em Espiau, B. [9] (INRIA, Fran�a).

\textbf{Defini��o}: Primitiva de Ve�culo � uma \emph{string} na linguagem de
programa��o, associada a uma Fun��o de Controle. Por exemplo,
$Forward_Speed_Control$, controle de velocidade do ve�culo.

\textbf{Defini��o}: O T�rmino de uma fun��o de controle ocorre nas seguintes
condi��es:
\begin{itemize}
  \item Em um tempo especificado;
  \item Quando a fun��o positiva definida do erro, $P(\cdot)$, assume valores
  limites especificados. Quando $b$ � um limite positivo e $F(\cdot)$ � um
  filtro passa-baixa, a Termina��o ocorre se
  $$F(P(e)) < b$$
\end{itemize}  
\textbf{Defini��o}: Um Comportamento (B) � descrito como a execu��o de uma
sequ�ncia particular de CFs, cada uma com sua termina��o. O estado de realizar
uma certa CF � um estado discreto do sistema. Um Comportamento pode ser
representado como uma rede de Petri, por exemplo.

\textbf{Defini��o}: Um Sistema de Controle H�brido � um sistema de controle de
elementos de hardware e software capaz de conduzir o ve�culo por um conjunto de
Comportamentos.

\textbf{Defini��o}: Um Plano de Miss�o � a sequ�ncia de Comportamentos
conduzidos durante cada fase da miss�o, com tratamento de falhas.

Healey define diversas Primitivas de Ve�culo para AUVs, mas ser�o estudadas as
Primitivas do Rob� MARIUS, de Silva, V., que � semelhante ao rob� DORIS,
objeto de estudo desta disserta��o.

Em 1996, Silva, V. et al [6] (Institute for Systems and Robotics, Lisboa),
projetaram, desenvolveram e testaram um sistema de controle de miss�o para o
MARIUS, rob� aut�nomo submarino. \emph{A Mission Control System} (MCS), o
conceito, aparece pela primeira vez na nomenclatura como um sistema que:
\emph{i)} habilita o operador a definir uma miss�o ao ve�culo em uma linguagem
de alto n�vel, que ser� traduzida em um plano de miss�o; \emph{ii)} prov�
ferramentas adequadas para converter um plano de miss�o em um programa de
miss�o que pode ser verificado e executado em tempo real; \emph{iii)} fornece
ao operador a capacidade de seguir o progresso do programa de miss�o enquanto
ele � executado, e modific�-lo se necess�rio;

O trabalho de Silva, V. [6], introduz novos e importantes conceitos chave para o
MCS: Tarefa do Sistema (\emph{System Task}), Primitiva do
Ve�culo (\emph{Vechicle Primitive}), Procedimento de Miss�o (\emph{Mission Procedure})
e Programa de Miss�o (\emph{Mission Program}). Al�m disso, a arquitetura do
ve�culo, por ser um AUV, possui sistemas e interconex�es
semelhantes ao rob� DORIS, estudo desta disserta��o.

A arquitetura do ve�culo DORIS teve grande influ�ncia da organiza��o do ve�culo
MARIUS descrita abaixo, figura~\ref{SILVA_1}:
\begin{itemize}
  \item \emph{Vehicle Support System} (VSS) - Controla a distribui��o de energia
  aos hardwares instalados no ve�culo, monitora consumo de energia e detecta
  falhas de hardware, podendo enviar comandos de emerg�ncia.
  \item \emph{Actuator Control System} (ACS) - Controla a velocidade de rota��o
  dos propulsores e posi��o dos ailerions e lemes. Os \emph{Set Points} dos
  atuadores s�o dados pelo \emph{Vehicle Guidance and Control System} (VGCS) e
  os dados dos atuadores s�o transmitidos para o \emph{Mission Control System}.
  \item \emph{Navigation System} (NS) - Estima posi��o linear e velocidade do
  ve�culo, orienta��o e velocidade angular. O sistema funde informa��es do
  \emph{Positioning System} (\emph{Long Baseline unit}) e \emph{Motion Sensor
  Integration System}, o qual inclui diversos sensores. As sa�das do NS s�o
  entradas do VGCS, e enviadas ao MCS.
  \item \emph{Vehicle Guidance and Control System} (VGCS) - Recebe como entrada
  as trajet�rias de refer�ncia pelo MCS, e os dados de navega��o do NS. Suas
  sa�das s�o \emph{Set Points} para velocidade de rota��o e outros atuadores do
  ACS, tal que o ve�culo siga a trajet�ria desejada mesmo com incertezas e
  dist�rbios.
  \item \emph{Communication System} (COMS) - Controla o link bidirecional usado
  pelo operador para passar miss�es ao MCS, e pelo ve�culo para passar status de
  miss�o ou estados do ve�culo.
  \item \emph{Environmental Inspection System} (EIS) - Coleta dados do ambiente
  com diversos sensores (inclusive c�meras), como temperatura, press�o, pH. �
  controlado pelo MCS.
  \item \emph{Data Logging System} (DLS) - Adquiri e armazena dados do ve�culo.
  \item \emph{Mission Control System} (MCS) - Sequencia e sincroniza a execu��o
  das tarefas b�sicas do ve�culo para uma determinada miss�o e prov� a
  recupera��o em caso de falhas.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/SILVA_1.pdf}
\caption{Arquitetura do Ve�culo MARIUS}
\label{SILVA_1}
\end{figure}

A seguir, ser�o apresentados os conceitos chave de Silva, inpirados nos
trabalhos de Espiau e Healey:\\

\textbf{Tarefa do Sistema} (ST): � a especifica��o param�trica de uma classe
de algoritmos ou processos que implementam uma funcionalidade b�sica em um rob�.
Reque a implementa��o de dois m�dulos: \textit{i}) um \emph{m�dulo Funcional}
que cont�m um determinado algoritmo e precesso, e transfere dados com outras
Tarefas do Sistema e dispositivos f�sicos; \textit{ii}) um \emph{m�dulo
Comando}, m�quina de estado finito, que recebe comandos externos, produz
mensagens de sa�da, e controla a sele��o de algoritmos, processos, e caminhos
dos dados para/de m�dulos Funcionais.

Na modelagem do sistema em redes de Petri, quando uma transi��o �
disparada, uma ST � executada, chamada atrav�s do seguinte cabe�alho:
$STname(D_{mode},Din_{st},P_m)$, onde $STname$ � o nome da ST, $D_{mode}$ � uma
string de dados de entrada que especifica um determinado algoritmo ou processo a
ser executado, e $Din_{st}$ � um conjunto de dados num�ricos que s�o entrada
desses algoritmos ou processos. $P_m$ � um par�metro para associar ST com
Primitivas do Ve�culo (descritos abaixo), indicando um n�mero finito de lugares
na rede de Petri que devem ser marcados de acordo com o tipo da sa�da das
mensagens das STs.

As STs do MARIUS s�o semelhantes aos blocos da organiza��o do ve�culo,
figura~\ref{SILVA_2}:
\emph{Vehicle Support Task} (VST), \emph{Actuator Control Task} (ACT),
\emph{Vehicle Navigation Task} (VNT), \emph{Motion Sensor Task} (MST),
\emph{Guidance and Control Task} (GCT), \emph{Vehicle Communications Task}
(VCT), \emph{Space and Time Task} (STT), \emph{Vehicle Log Taks} (VLT). 

\begin{figure}[H]
\centering
\includegraphics[width=1\columnwidth]{figs/SILVA_2.pdf}
\caption{Tarefas de Sistema do ve�culo MARIUS}
\label{SILVA_2}
\end{figure}

O exemplo de um cabe�alho que chama uma ST seria:
$GCT(YAW\_AUTO,\psi,p_{yaw\_auto})$, onde $GCT$ � o nome da ST, $YAW\_AUTO$
seleciona um modo de opera��o particular que implementa um controle autom�tico
para guinada (\emph{yaw}), e $\psi$ � �ngulo \emph{set-Point}.

\textbf{Primitiva do Ve�culo} (VP): � a especifica��o param�trica de um modo
de opera��o elementar em um rob�. Corresponde a ativa��o l�gica e sincronizada
de um n�mero de STs, as quais conduzem a um comportamento l�gico e estrututrado
do ve�culo. Existe um conjunto de pr�-condi��es, recursos alocados, exce��es e
p�s-condi��es associados �s VPs, assim como as RT (Robot-Task) definidas em
Espiau.

A rede de Petri associada � VP � uma tupla de 5 par�metros
$(P_{VP},T_{VP},A_{VP},\omega_{VP},X_{VP})$, onde $P_{VP},T_{VP}$ e $A_{VP}$ s�o
os conjuntos de lugares, transi��es e arcos, respectivamente, $\omega_{VP}$ �
uma fun��o peso, e $X_{VP_{0}}$ � a condi��o inicial da rede de Petri. O
conjunto dos lugares pode ser decomposto em $P_{VP}=P_{pre}\cup P_{res}\cup
P_{err}\cup P_{loc}\cup P{pos}$, onde $P_{pre}$, $P_{res}$, $P_{err}$,
$P_{loc}$ e $P{pos}$ denotam os subconjuntos de lugares das pr�-condi��es,
recursos alocados, erros, p�s-condi��es, e os outros estados da rede de Petri,
respectivamente.

A transi��o em um Processo de Miss�o (descrito abaixo) inicializa a execu��o de
uma VP, chamada com o seguinte cabe�alho: $VPname(Din_{vp},P_m)$, onde
$Din_{vp}$ � o conjunto de dados num�ricos que s�o entrada da VP e $P_m$ � o
par�metro que associa a VP ao Processo de Miss�o.

\textbf{Processo de Miss�o} (MP): � a especifica��o param�trica de uma A��o de
um sistema rob�tico. MP corresponde � cadeia l�gica e temporal de VPs e,
possivelmente, outras MPs, as quais, em conjunto, executam uma determinada A��o.

A modelagem de MPs tamb�m pode ser em redes de Petri e � semelhante � VP, por�m
em maior alto n�vel. O cabe�alho �: $MPname(Din_{mp},P_m)$, onde
$Din_{mp}$ � o conjunto de dados num�ricos que s�o entrada do MP e $P_m$ �
similar � VP.

As VPs e MPs apresentadas por Silva, em [6], ser�o abordadas ao longo desta
disserta��o de metrado, por ter grande semelhan�a �s caracter�sticas do rob�
DORIS, apesar de ter como enfoque AUVs. A fim de exemplificar todo o formalismo
apresentado, a modelagem da VP
$KeepHeading(\psi,p_{\textrm{Exit}},p_{\textrm{End}})$ ser� avaliada. A
VP � respons�vel por levar o rob� a um determinado \emph{Set-Point} ($\psi$),
$p_{\textrm{Exit}}$ � um lugar na rede de Petri que deve ser marcado como parada
da execu��o da VP e $p_{\textrm{End}}$ � um lugar que tem a informa��o de
t�rmino da execu��o da VP. A �nica pr�-condi��o para a execu��o da VP � a
inicializa��o de todas as ST: comando
$Init(p_{\textrm{End}},p_{\textrm{Abort}})$. N�o h� p�s-condi��es e o recurso
alocado para a VP � o leme: $P_{\textrm{pre}}=\{p_{\textrm{Init}}\}$, e
$P_{res}=\{p_{\textrm{Rudder}}\}$.
A rede de Petri da VP pode ser vista na figura~\ref{SILVA_3}.

\begin{figure}[H]
\centering
\includegraphics[width=0.87\columnwidth]{figs/SILVA_3.png}
\caption{Rede de Petri da Primitiva de Ve�culo KeepHeading do rob� MARIUS}
\label{SILVA_3}
\end{figure}

O estado inicial da rede de Petri �: $$M
=\{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\}$$, cujos lugares
s�o:
$$M
=\{P_{\textrm{KeepHeading}},P_{\textrm{Rudder}},P_{\textrm{Init}},P_0,P_1,P_{\textrm{cmmd\_on}},P_2,P_3,P_{\textrm{yaw\_auto}},P_4,P_5,P_{\textrm{auto\_on}},\ldots$$
$$P_6,P_{\textrm{yaw\_on}},P_{\textrm{Exit}},P_7,P_8,P_{\textrm{yaw\_off}},P_9,P{10},P_{\textrm{yaw\_manual}},P_{11},P_{12},P_{\textrm{manual\_on}},\ldots$$
$$P_{13},P_{\textrm{cmmd\_off}},P_{\textrm{success}},P_{\textrm{Rudder}},P_{\textrm{End}}\}$$

As suas transi��es s�o:
\begin{enumerate}
  \item A transi��o $T0$ s� pode ser disparada quando o recurso leme fica
  dispon�vel e as ST s�o inicializadas:
 $$M
=\{1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\}$$
Ap�s a transi��o $T0$:
  $$M
=\{0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\}$$  
  \item A transi��o $VCT(RUDDER\_CMMD,ON,P_{\textrm{cmmd\_on}})$
  (\emph{Vehicle Communications Task}) � ST para desabilitar comandos diretos ao
  leme do console (operador).
$$M
=\{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\}$$ 
  \item A transi��o $T1$ � habilitada ap�s a altera��o da ST VCT for conclu�da
  e $P_{\textrm{cmmd\_on}}$ for marcada (token). $$M
=\{0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\}$$
Ap�s a transi��o $T1$:
$$M
=\{0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\}$$
  \item As transi��es $ACT(AUTO\_RUDDER,P_{\textrm{auto\_on}})$
  (\emph{Actuator Control Task}) e $GCT(YAW\_AUTO,\Psi,P_{\textrm{yaw\_auto}})$
  (\emph{Guidance and Control Task}) s�o ativadas paralelamente. A primeira est�
  associada � ST para habilitar o leme a receber comandos diretamente do
  controlador. A ST GCT � requisitada para ativar o controle de guinada
  (\emph{Yaw}) e recebe como argumento o \emph{set-point} $\psi$.
$$M
=\{0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\}$$
  \item A transi��o $MST(CNTR\_YAW\_ON,P_{\textrm{yaw\_on}})$ (\emph{Motion
  Sensor Task}) � habilitada ap�s as altera��es das STs ACT e GCT serem
  conclu�das.
  $P_{\textrm{yaw\_auto}}$ e $P_{\textrm{autoon}}$ s�o marcados (tokens):
  $$M
=\{0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\}$$
A ST MST � chamada para enviar dados dos sensores de �ngulo de guinada
periodicamente para a ST GCT.
Ap�s a transi��o
$MST(CNTR\_YAW\_ON,P_{\textrm{yaw\_on}})$:
  $$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\}$$
  \item A transi��o $T2$ s� � habilitada quando a altera��o da ST MST for
  conclu�da e, assim, $P_{\textrm{yaw\_on}}$ adquire um token:
    $$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\}$$
Ap�s transi��o de $T2$:
$$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0\}$$
  \item Em $P_7$, o rob� permanece em sistema de controle em malha fechada da VP
  KeepHeading at� que o lugar $P_{\textrm{Exit}}$ seja marcado:
$$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0\}$$
A transi��o $MST(CNTR\_YAW\_OFF,P_{\textrm{yaw\_off}})$ �, ent�o, habilitada. A
ST MST �, novamente, chamada para desabilitar o envio de mensagens � GCT. Ap�s a
transi��o da $MST(CNTR\_YAW\_OFF,P_{\textrm{yaw\_off}})$:
$$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0\}$$
  \item As transi��es $T3$, $GCT(YAW\_MANUAL,P_{\textrm{yaw\_manual}})$,
  $ACT(MANUAL\_RUDDER,P_{\textrm{manual\_on}})$ e
  $VCT(RUDDER\_CMMD,OFF,P_{\textrm{cmmd\_off}})$ alteram as STs GCT, ACT e VCT
  para levarem ao estados manual, como era inicialmente. Os estados para isso
  s�o:
$$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0\}$$
$$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0\}$$
$$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0\}$$
$$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0\}$$
$$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0\}$$
$$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0\}$$
$$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0\}$$  
  \item A �ltima transi��o $T5$ libera o recurso $P_{\textrm{Rudder}}$ e
  finaliza a VP no lugar $P_{\textrm{End}}$:
$$M
=\{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1\}$$
\end{enumerate} 

Silva desenvolveu os softwares CORAL e ATOL para implementa��o das VPs e STs em
redes de Petri de forma que um usu�rio final, como um operador, pudesse
facilmente criar seus MPs. A grande contribui��o 



